<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Halide: Halide::ScheduleHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_schedule_handle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_schedule_handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::ScheduleHandle Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A wrapper around a schedule used for common schedule manipulations.  
 <a href="class_halide_1_1_schedule_handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ad2d8b9dd4f722890654fa6c911e1aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a5ad2d8b9dd4f722890654fa6c911e1aa">ScheduleHandle</a> (<a class="el" href="struct_halide_1_1_internal_1_1_schedule.html">Internal::Schedule</a> &amp;s)</td></tr>
<tr class="separator:a5ad2d8b9dd4f722890654fa6c911e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dcba5e287a284bfdb2eba997659daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a82dcba5e287a284bfdb2eba997659daa">split</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> old, <a class="el" href="class_halide_1_1_var.html">Var</a> outer, <a class="el" href="class_halide_1_1_var.html">Var</a> inner, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> factor)</td></tr>
<tr class="memdesc:a82dcba5e287a284bfdb2eba997659daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1.  <a href="#a82dcba5e287a284bfdb2eba997659daa">More...</a><br/></td></tr>
<tr class="separator:a82dcba5e287a284bfdb2eba997659daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ae03504ed0261b1ffba9935844c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a341ae03504ed0261b1ffba9935844c2d">parallel</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a341ae03504ed0261b1ffba9935844c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be traversed in parallel.  <a href="#a341ae03504ed0261b1ffba9935844c2d">More...</a><br/></td></tr>
<tr class="separator:a341ae03504ed0261b1ffba9935844c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965ef3a905df60c3f59ca3743cbf668d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d">vectorize</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a965ef3a905df60c3f59ca3743cbf668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be computed all-at-once as a single vector.  <a href="#a965ef3a905df60c3f59ca3743cbf668d">More...</a><br/></td></tr>
<tr class="separator:a965ef3a905df60c3f59ca3743cbf668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf1e85d5dcb74d761d15546b5c6de90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a0cf1e85d5dcb74d761d15546b5c6de90">unroll</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a0cf1e85d5dcb74d761d15546b5c6de90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be completely unrolled.  <a href="#a0cf1e85d5dcb74d761d15546b5c6de90">More...</a><br/></td></tr>
<tr class="separator:a0cf1e85d5dcb74d761d15546b5c6de90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30332ea58e8ff19e426565ddb8814ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a30332ea58e8ff19e426565ddb8814ae2">vectorize</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, int factor)</td></tr>
<tr class="memdesc:a30332ea58e8ff19e426565ddb8814ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then vectorize the inner dimension.  <a href="#a30332ea58e8ff19e426565ddb8814ae2">More...</a><br/></td></tr>
<tr class="separator:a30332ea58e8ff19e426565ddb8814ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab78461c04452c17b3b1534dcdd84505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aab78461c04452c17b3b1534dcdd84505">unroll</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, int factor)</td></tr>
<tr class="memdesc:aab78461c04452c17b3b1534dcdd84505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then unroll the inner dimension.  <a href="#aab78461c04452c17b3b1534dcdd84505">More...</a><br/></td></tr>
<tr class="separator:aab78461c04452c17b3b1534dcdd84505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cde6c7be1ecf477045302fc3f0d897e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a4cde6c7be1ecf477045302fc3f0d897e">bound</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr class="memdesc:a4cde6c7be1ecf477045302fc3f0d897e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically declare that the range over which a function should be evaluated is given by the second and third arguments.  <a href="#a4cde6c7be1ecf477045302fc3f0d897e">More...</a><br/></td></tr>
<tr class="separator:a4cde6c7be1ecf477045302fc3f0d897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5034fe9fbd89a2e6262bbdf3ac02a9fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a5034fe9fbd89a2e6262bbdf3ac02a9fd">tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> xo, <a class="el" href="class_halide_1_1_var.html">Var</a> yo, <a class="el" href="class_halide_1_1_var.html">Var</a> xi, <a class="el" href="class_halide_1_1_var.html">Var</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr class="memdesc:a5034fe9fbd89a2e6262bbdf3ac02a9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards.  <a href="#a5034fe9fbd89a2e6262bbdf3ac02a9fd">More...</a><br/></td></tr>
<tr class="separator:a5034fe9fbd89a2e6262bbdf3ac02a9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac11ba997fa44891f995d9affb9591e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a8ac11ba997fa44891f995d9affb9591e">tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> xi, <a class="el" href="class_halide_1_1_var.html">Var</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr class="memdesc:a8ac11ba997fa44891f995d9affb9591e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shorter form of tile, which reuses the old variable names as the new outer dimensions.  <a href="#a8ac11ba997fa44891f995d9affb9591e">More...</a><br/></td></tr>
<tr class="separator:a8ac11ba997fa44891f995d9affb9591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f456d05588b88f1ea6707875bf68a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a83f456d05588b88f1ea6707875bf68a8">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y)</td></tr>
<tr class="memdesc:a83f456d05588b88f1ea6707875bf68a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder two dimensions so that x is traversed inside y.  <a href="#a83f456d05588b88f1ea6707875bf68a8">More...</a><br/></td></tr>
<tr class="separator:a83f456d05588b88f1ea6707875bf68a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33060b1c2876ccb6fe025d4a401b95a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a33060b1c2876ccb6fe025d4a401b95a7">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z)</td></tr>
<tr class="memdesc:a33060b1c2876ccb6fe025d4a401b95a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder three dimensions to have the given nesting order, from innermost out.  <a href="#a33060b1c2876ccb6fe025d4a401b95a7">More...</a><br/></td></tr>
<tr class="separator:a33060b1c2876ccb6fe025d4a401b95a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24779097a7a7988bc37625c49d0ebeb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a24779097a7a7988bc37625c49d0ebeb5">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w)</td></tr>
<tr class="memdesc:a24779097a7a7988bc37625c49d0ebeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder four dimensions to have the given nesting order, from innermost out.  <a href="#a24779097a7a7988bc37625c49d0ebeb5">More...</a><br/></td></tr>
<tr class="separator:a24779097a7a7988bc37625c49d0ebeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0e628eaa175301bc30125b4670d79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a4e0e628eaa175301bc30125b4670d79c">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t)</td></tr>
<tr class="memdesc:a4e0e628eaa175301bc30125b4670d79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder five dimensions to have the given nesting order, from innermost out.  <a href="#a4e0e628eaa175301bc30125b4670d79c">More...</a><br/></td></tr>
<tr class="separator:a4e0e628eaa175301bc30125b4670d79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc45869ffbe51fa95f3fe7bc0f8463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ae3cc45869ffbe51fa95f3fe7bc0f8463">rename</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> old_name, <a class="el" href="class_halide_1_1_var.html">Var</a> new_name)</td></tr>
<tr class="memdesc:ae3cc45869ffbe51fa95f3fe7bc0f8463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a dimension.  <a href="#ae3cc45869ffbe51fa95f3fe7bc0f8463">More...</a><br/></td></tr>
<tr class="separator:ae3cc45869ffbe51fa95f3fe7bc0f8463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aac3fd49ab9a92485f2a24ed997b2c46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x)</td></tr>
<tr class="memdesc:aac3fd49ab9a92485f2a24ed997b2c46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices.  <a href="#aac3fd49ab9a92485f2a24ed997b2c46e">More...</a><br/></td></tr>
<tr class="separator:aac3fd49ab9a92485f2a24ed997b2c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964092fe660a59129d3ac20feb1867b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aa964092fe660a59129d3ac20feb1867b">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y)</td></tr>
<tr class="memdesc:aa964092fe660a59129d3ac20feb1867b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices.  <a href="#aa964092fe660a59129d3ac20feb1867b">More...</a><br/></td></tr>
<tr class="separator:aa964092fe660a59129d3ac20feb1867b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6c5ca23e42a04a654a0e6daaf81f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a43f6c5ca23e42a04a654a0e6daaf81f7">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_z)</td></tr>
<tr class="memdesc:a43f6c5ca23e42a04a654a0e6daaf81f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices.  <a href="#a43f6c5ca23e42a04a654a0e6daaf81f7">More...</a><br/></td></tr>
<tr class="separator:a43f6c5ca23e42a04a654a0e6daaf81f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a138e0ce958cda731f080088fb7f89a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x)</td></tr>
<tr class="memdesc:a138e0ce958cda731f080088fb7f89a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices.  <a href="#a138e0ce958cda731f080088fb7f89a3b">More...</a><br/></td></tr>
<tr class="separator:a138e0ce958cda731f080088fb7f89a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1a089eab2c71f57e6e1f2f225b683f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a2c1a089eab2c71f57e6e1f2f225b683f">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y)</td></tr>
<tr class="memdesc:a2c1a089eab2c71f57e6e1f2f225b683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices.  <a href="#a2c1a089eab2c71f57e6e1f2f225b683f">More...</a><br/></td></tr>
<tr class="separator:a2c1a089eab2c71f57e6e1f2f225b683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11aebb55ad93ae7a2d9e80ebf260f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#abc11aebb55ad93ae7a2d9e80ebf260f4">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> block_z)</td></tr>
<tr class="memdesc:abc11aebb55ad93ae7a2d9e80ebf260f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices.  <a href="#abc11aebb55ad93ae7a2d9e80ebf260f4">More...</a><br/></td></tr>
<tr class="separator:abc11aebb55ad93ae7a2d9e80ebf260f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf7d873d44842d0f3116e6fbebd86507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x)</td></tr>
<tr class="memdesc:acf7d873d44842d0f3116e6fbebd86507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices.  <a href="#acf7d873d44842d0f3116e6fbebd86507">More...</a><br/></td></tr>
<tr class="separator:acf7d873d44842d0f3116e6fbebd86507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf73d51bde948e08ac781639b4008d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a6bf73d51bde948e08ac781639b4008d2">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y)</td></tr>
<tr class="memdesc:a6bf73d51bde948e08ac781639b4008d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices.  <a href="#a6bf73d51bde948e08ac781639b4008d2">More...</a><br/></td></tr>
<tr class="separator:a6bf73d51bde948e08ac781639b4008d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033f1275529d5387491db06718fe434c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a033f1275529d5387491db06718fe434c">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> block_z, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_z)</td></tr>
<tr class="memdesc:a033f1275529d5387491db06718fe434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices.  <a href="#a033f1275529d5387491db06718fe434c">More...</a><br/></td></tr>
<tr class="separator:a033f1275529d5387491db06718fe434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aca3bf0f68bb50a1e2a7920cffc024737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, int x_size)</td></tr>
<tr class="memdesc:aca3bf0f68bb50a1e2a7920cffc024737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices.  <a href="#aca3bf0f68bb50a1e2a7920cffc024737">More...</a><br/></td></tr>
<tr class="separator:aca3bf0f68bb50a1e2a7920cffc024737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed2ef297d71d526311638e3c59ff8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#a16ed2ef297d71d526311638e3c59ff8a">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, int x_size, int y_size)</td></tr>
<tr class="memdesc:a16ed2ef297d71d526311638e3c59ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices.  <a href="#a16ed2ef297d71d526311638e3c59ff8a">More...</a><br/></td></tr>
<tr class="separator:a16ed2ef297d71d526311638e3c59ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9893c5369e40d5df86673e34894bf68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html#ab9893c5369e40d5df86673e34894bf68">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, int x_size, int y_size, int z_size)</td></tr>
<tr class="memdesc:ab9893c5369e40d5df86673e34894bf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices.  <a href="#ab9893c5369e40d5df86673e34894bf68">More...</a><br/></td></tr>
<tr class="separator:ab9893c5369e40d5df86673e34894bf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A wrapper around a schedule used for common schedule manipulations. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00133">133</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5ad2d8b9dd4f722890654fa6c911e1aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::ScheduleHandle::ScheduleHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_schedule.html">Internal::Schedule</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l00138">138</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a82dcba5e287a284bfdb2eba997659daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1. </p>
<p>The inner and outer subdimensions can then be dealt with using the other scheduling calls. It's ok to reuse the old variable name as either the inner or outer variable. </p>

</div>
</div>
<a class="anchor" id="a341ae03504ed0261b1ffba9935844c2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be traversed in parallel. </p>

</div>
</div>
<a class="anchor" id="a965ef3a905df60c3f59ca3743cbf668d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be computed all-at-once as a single vector. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of vectorize you want the two argument form. The variable to be vectorized should be the innermost one. </p>

</div>
</div>
<a class="anchor" id="a0cf1e85d5dcb74d761d15546b5c6de90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a dimension to be completely unrolled. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of unroll you want the two-argument form. </p>

</div>
</div>
<a class="anchor" id="a30332ea58e8ff19e426565ddb8814ae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension by the given factor, then vectorize the inner dimension. </p>
<p>This is how you vectorize a loop of unknown size. The variable to be vectorized should be the innermost one. After this call, var refers to the outer dimension of the split. </p>

</div>
</div>
<a class="anchor" id="aab78461c04452c17b3b1534dcdd84505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a dimension by the given factor, then unroll the inner dimension. </p>
<p>This is how you unroll a loop of unknown size by some constant factor. After this call, var refers to the outer dimension of the split. </p>

</div>
</div>
<a class="anchor" id="a4cde6c7be1ecf477045302fc3f0d897e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically declare that the range over which a function should be evaluated is given by the second and third arguments. </p>
<p>This can let <a class="el" href="namespace_halide.html">Halide</a> perform some optimizations. E.g. if you know there are going to be 4 color channels, you can completely vectorize the color channel dimension without the overhead of splitting it up. If bounds inference decides that it requires more of this function than the bounds you have stated, a runtime error will occur when you try to run your pipeline. </p>

</div>
</div>
<a class="anchor" id="a5034fe9fbd89a2e6262bbdf3ac02a9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards. </p>
<p>This gives a tiled traversal. </p>

</div>
</div>
<a class="anchor" id="a8ac11ba997fa44891f995d9affb9591e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A shorter form of tile, which reuses the old variable names as the new outer dimensions. </p>

</div>
</div>
<a class="anchor" id="a83f456d05588b88f1ea6707875bf68a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder two dimensions so that x is traversed inside y. </p>
<p>Does not affect the nesting order of other dimensions. E.g, if you say foo(x, y, z, w) = bar; foo.reorder(w, x); then foo will be traversed in the order (w, y, z, x), from innermost outwards. </p>

</div>
</div>
<a class="anchor" id="a33060b1c2876ccb6fe025d4a401b95a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder three dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a24779097a7a7988bc37625c49d0ebeb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder four dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a4e0e628eaa175301bc30125b4670d79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder five dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="ae3cc45869ffbe51fa95f3fe7bc0f8463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a dimension. </p>
<p>Equivalent to split with a inner size of one. </p>

</div>
</div>
<a class="anchor" id="aac3fd49ab9a92485f2a24ed997b2c46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to cuda threads. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="aa964092fe660a59129d3ac20feb1867b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to cuda threads. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a43f6c5ca23e42a04a654a0e6daaf81f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to cuda threads. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a138e0ce958cda731f080088fb7f89a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices. </p>
<p>This is useful for scheduling stages that will run serially within each cuda block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a2c1a089eab2c71f57e6e1f2f225b683f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices. </p>
<p>This is useful for scheduling stages that will run serially within each cuda block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="abc11aebb55ad93ae7a2d9e80ebf260f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices. </p>
<p>This is useful for scheduling stages that will run serially within each cuda block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="acf7d873d44842d0f3116e6fbebd86507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="a6bf73d51bde948e08ac781639b4008d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="a033f1275529d5387491db06718fe434c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to cuda block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="aca3bf0f68bb50a1e2a7920cffc024737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<a class="anchor" id="a16ed2ef297d71d526311638e3c59ff8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<a class="anchor" id="ab9893c5369e40d5df86673e34894bf68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&amp; Halide::ScheduleHandle::cuda_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to cuda block indices and the coordinates within each tile to cuda thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a></li>
    <li class="footer">Generated on Wed May 29 2013 16:11:50 for Halide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
