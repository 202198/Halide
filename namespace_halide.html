<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Halide: Halide Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_halide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_argument.html">Argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing an argument to a halide-generated function.  <a href="struct_halide_1_1_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal representation of an image, or other dense array data.  <a href="class_halide_1_1_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Vars.  <a href="class_halide_1_1_func_ref_var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.  <a href="class_halide_1_1_func_ref_expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a schedule used for common schedule manipulations.  <a href="class_halide_1_1_schedule_handle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A halide function.  <a href="class_halide_1_1_func.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a dense multidimensional array containing scalar values of type T.  <a href="class_halide_1_1_image.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of <a class="el" href="namespace_halide.html">Halide</a> syntax.  <a href="struct_halide_1_1_expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_param.html">Param</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar parameter to a halide pipeline.  <a href="class_halide_1_1_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_image_param.html">ImageParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> parameter to a halide pipeline.  <a href="class_halide_1_1_image_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_r_var.html">RVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reduction variable represents a single dimension of a reduction domain (<a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a>).  <a href="class_halide_1_1_r_var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_r_dom.html">RDom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional domain over which to iterate.  <a href="class_halide_1_1_r_dom.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="struct_halide_1_1_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespace_halide.html">Halide</a> variable, to be used when defining functions.  <a href="class_halide_1_1_var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">cast</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a51c6da1a731c0804063458b531e8a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="#a51c6da1a731c0804063458b531e8a849">More...</a><br/></td></tr>
<tr class="separator:a51c6da1a731c0804063458b531e8a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a69ce0e6da961a52ace4b8fa8444fac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="#a69ce0e6da961a52ace4b8fa8444fac20">More...</a><br/></td></tr>
<tr class="separator:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">operator+</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br/></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77e71422999076fa3339829ac8c30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">operator+=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:acd77e71422999076fa3339829ac8c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="#acd77e71422999076fa3339829ac8c30d">More...</a><br/></td></tr>
<tr class="separator:acd77e71422999076fa3339829ac8c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a86f3eb27005363158ca0e934811c98ed">More...</a><br/></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80881209a15ed749e168d6edbcb6f687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a80881209a15ed749e168d6edbcb6f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="#a80881209a15ed749e168d6edbcb6f687">More...</a><br/></td></tr>
<tr class="separator:a80881209a15ed749e168d6edbcb6f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db82f1af5cd7492bb503c2238ade8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">operator-=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a94db82f1af5cd7492bb503c2238ade8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="#a94db82f1af5cd7492bb503c2238ade8a">More...</a><br/></td></tr>
<tr class="separator:a94db82f1af5cd7492bb503c2238ade8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">operator*</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a908c6748ab34a4a66274b196b6900af5">More...</a><br/></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">operator*=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="#ac0c84f284a38d6018e2d4e5d075c8b5b">More...</a><br/></td></tr>
<tr class="separator:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">operator/</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br/></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da6820c40a5911fb23d973283487f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">operator/=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3c0da6820c40a5911fb23d973283487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="#a3c0da6820c40a5911fb23d973283487f">More...</a><br/></td></tr>
<tr class="separator:a3c0da6820c40a5911fb23d973283487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">operator%</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br/></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">operator&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#af9105ae9f0995f450825e522170f5d1e">More...</a><br/></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">operator&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#abbad5ee20448455260670dec22c76a21">More...</a><br/></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">operator&lt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br/></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">operator&gt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br/></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">operator==</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br/></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">operator!=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a8d3d11c86964dbb2586103744cac1614">More...</a><br/></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">operator&amp;&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a02df159d6ed5236cc8e02d04bf72be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="#a02df159d6ed5236cc8e02d04bf72be4f">More...</a><br/></td></tr>
<tr class="separator:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">operator||</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="#a3528931d7929d533103ada2badca092c">More...</a><br/></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb54256bfab344b6720775cf2e0936e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">operator!</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:afb54256bfab344b6720775cf2e0936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="#afb54256bfab344b6720775cf2e0936e0">More...</a><br/></td></tr>
<tr class="separator:afb54256bfab344b6720775cf2e0936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">max</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br/></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a38b5db24ca379dda8241433c0014c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>.  <a href="#a38b5db24ca379dda8241433c0014c940">More...</a><br/></td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fc11b69e1ae900cebae51c319a1caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa">clamp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> max_val)</td></tr>
<tr class="memdesc:a41fc11b69e1ae900cebae51c319a1caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="#a41fc11b69e1ae900cebae51c319a1caa">More...</a><br/></td></tr>
<tr class="separator:a41fc11b69e1ae900cebae51c319a1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">abs</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="#ae698f4bfd37d3d15cee4bf22c4627e0d">More...</a><br/></td></tr>
<tr class="separator:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee021c55c8ca2bdaae9d2dc2000870c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1ee021c55c8ca2bdaae9d2dc2000870c">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c)</td></tr>
<tr class="memdesc:a1ee021c55c8ca2bdaae9d2dc2000870c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression equivalent to the ternary operator in C.  <a href="#a1ee021c55c8ca2bdaae9d2dc2000870c">More...</a><br/></td></tr>
<tr class="separator:a1ee021c55c8ca2bdaae9d2dc2000870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fca22f79625765096133e39caee5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a5e1fca22f79625765096133e39caee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="#a5e1fca22f79625765096133e39caee5e">More...</a><br/></td></tr>
<tr class="separator:a5e1fca22f79625765096133e39caee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">asin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="#a3bfc77a80e6b40a6c00899a8e2ad1f28">More...</a><br/></td></tr>
<tr class="separator:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">cos</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a7e1ef33189b99c7b8bc73b5e10121834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="#a7e1ef33189b99c7b8bc73b5e10121834">More...</a><br/></td></tr>
<tr class="separator:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64d3ef272e07177d95b624968951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">acos</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a722a64d3ef272e07177d95b624968951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="#a722a64d3ef272e07177d95b624968951">More...</a><br/></td></tr>
<tr class="separator:a722a64d3ef272e07177d95b624968951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f43994d3cf73c20b7eb62b243076e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">tan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ad18f43994d3cf73c20b7eb62b243076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="#ad18f43994d3cf73c20b7eb62b243076e">More...</a><br/></td></tr>
<tr class="separator:ad18f43994d3cf73c20b7eb62b243076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">atan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abe3b0ec19519602bc880a1ae0236f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="#abe3b0ec19519602bc880a1ae0236f1c3">More...</a><br/></td></tr>
<tr class="separator:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05bc670b713a278f8182457a750bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">sinh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abe05bc670b713a278f8182457a750bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="#abe05bc670b713a278f8182457a750bd9">More...</a><br/></td></tr>
<tr class="separator:abe05bc670b713a278f8182457a750bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">asinh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">More...</a><br/></td></tr>
<tr class="separator:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aff5fc199ecbabe209ce32ec507292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">cosh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a68aff5fc199ecbabe209ce32ec507292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="#a68aff5fc199ecbabe209ce32ec507292">More...</a><br/></td></tr>
<tr class="separator:a68aff5fc199ecbabe209ce32ec507292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">acosh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="#a2ce048ac6f7c309d26c83fbc3132be2b">More...</a><br/></td></tr>
<tr class="separator:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15a9760067c05d2e5a343f529188be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">tanh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:acb15a9760067c05d2e5a343f529188be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="#acb15a9760067c05d2e5a343f529188be">More...</a><br/></td></tr>
<tr class="separator:acb15a9760067c05d2e5a343f529188be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd93e33e8d82be7cf9487e881d834ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">atanh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:acd93e33e8d82be7cf9487e881d834ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="#acd93e33e8d82be7cf9487e881d834ec9">More...</a><br/></td></tr>
<tr class="separator:acd93e33e8d82be7cf9487e881d834ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7f08f13439b86581a47162e1a2d2de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abc7f08f13439b86581a47162e1a2d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="#abc7f08f13439b86581a47162e1a2d2de">More...</a><br/></td></tr>
<tr class="separator:abc7f08f13439b86581a47162e1a2d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb75ff010919c00492e4f654a4d8f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4fb75ff010919c00492e4f654a4d8f85">hypot</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4fb75ff010919c00492e4f654a4d8f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="#a4fb75ff010919c00492e4f654a4d8f85">More...</a><br/></td></tr>
<tr class="separator:a4fb75ff010919c00492e4f654a4d8f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6187068d6e839e548776dfa7dde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a877c6187068d6e839e548776dfa7dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="#a877c6187068d6e839e548776dfa7dde3">More...</a><br/></td></tr>
<tr class="separator:a877c6187068d6e839e548776dfa7dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1c38239e6e977fea90b94217499ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a02f1c38239e6e977fea90b94217499ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="#a02f1c38239e6e977fea90b94217499ae">More...</a><br/></td></tr>
<tr class="separator:a02f1c38239e6e977fea90b94217499ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed670387016322f8db2b7abdecdc0e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">floor</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:aed670387016322f8db2b7abdecdc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="#aed670387016322f8db2b7abdecdc0e4c">More...</a><br/></td></tr>
<tr class="separator:aed670387016322f8db2b7abdecdc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dde32195d1ae83082c15fd11d5d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">ceil</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a070dde32195d1ae83082c15fd11d5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="#a070dde32195d1ae83082c15fd11d5d90">More...</a><br/></td></tr>
<tr class="separator:a070dde32195d1ae83082c15fd11d5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2090a77072af682d9e2daea086d2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">round</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a9d2090a77072af682d9e2daea086d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="#a9d2090a77072af682d9e2daea086d2fe">More...</a><br/></td></tr>
<tr class="separator:a9d2090a77072af682d9e2daea086d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">pow</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br/></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82296f14959ca5344add163ebd60304e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a82296f14959ca5344add163ebd60304e">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:a82296f14959ca5344add163ebd60304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an expression on an output stream (such as std::cout) in a human-readable form.  <a href="#a82296f14959ca5344add163ebd60304e">More...</a><br/></td></tr>
<tr class="separator:a82296f14959ca5344add163ebd60304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eecaf53e09386aa3239e758e928a92f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8eecaf53e09386aa3239e758e928a92f">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="struct_halide_1_1_type.html">Type</a>)</td></tr>
<tr class="memdesc:a8eecaf53e09386aa3239e758e928a92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide type on an output stream (such as std::cout) in a human-readable form.  <a href="#a8eecaf53e09386aa3239e758e928a92f">More...</a><br/></td></tr>
<tr class="separator:a8eecaf53e09386aa3239e758e928a92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57190a14ea6851c5ce46eaedaa77d21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57190a14ea6851c5ce46eaedaa77d21a">lambda</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a57190a14ea6851c5ce46eaedaa77d21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a zero-dimensional halide function that returns the given expression.  <a href="#a57190a14ea6851c5ce46eaedaa77d21a">More...</a><br/></td></tr>
<tr class="separator:a57190a14ea6851c5ce46eaedaa77d21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7305aa7d85b97f0900d7f035578ce41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa7305aa7d85b97f0900d7f035578ce41">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:aa7305aa7d85b97f0900d7f035578ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1-D halide function in the first argument that returns the second argument.  <a href="#aa7305aa7d85b97f0900d7f035578ce41">More...</a><br/></td></tr>
<tr class="separator:aa7305aa7d85b97f0900d7f035578ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bcf8b4f9e47c294dc8eb7f3784fed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a53bcf8b4f9e47c294dc8eb7f3784fed2">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a53bcf8b4f9e47c294dc8eb7f3784fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2-D halide function in the first two arguments that returns the last argument.  <a href="#a53bcf8b4f9e47c294dc8eb7f3784fed2">More...</a><br/></td></tr>
<tr class="separator:a53bcf8b4f9e47c294dc8eb7f3784fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938729e358e952cd3142850e6307adf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a938729e358e952cd3142850e6307adf4">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a938729e358e952cd3142850e6307adf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3-D halide function in the first three arguments that returns the last argument.  <a href="#a938729e358e952cd3142850e6307adf4">More...</a><br/></td></tr>
<tr class="separator:a938729e358e952cd3142850e6307adf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e105f7398081a2353df028af3ca79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae8e105f7398081a2353df028af3ca79a">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ae8e105f7398081a2353df028af3ca79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 4-D halide function in the first four arguments that returns the last argument.  <a href="#ae8e105f7398081a2353df028af3ca79a">More...</a><br/></td></tr>
<tr class="separator:ae8e105f7398081a2353df028af3ca79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ddeb0daa2a8445c23381817eea573"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a526ddeb0daa2a8445c23381817eea573">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_halide_1_1_r_var.html">RVar</a>)</td></tr>
<tr class="memdesc:a526ddeb0daa2a8445c23381817eea573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in a human-readable form.  <a href="#a526ddeb0daa2a8445c23381817eea573">More...</a><br/></td></tr>
<tr class="separator:a526ddeb0daa2a8445c23381817eea573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccef6c4dd64764e831b56cd14e410c0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ccef6c4dd64764e831b56cd14e410c0">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>)</td></tr>
<tr class="memdesc:a4ccef6c4dd64764e831b56cd14e410c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> in a human-readable form.  <a href="#a4ccef6c4dd64764e831b56cd14e410c0">More...</a><br/></td></tr>
<tr class="separator:a4ccef6c4dd64764e831b56cd14e410c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf59f500385c448b26d0d245f55b23f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acf59f500385c448b26d0d245f55b23f4">Int</a> (int bits, int width=1)</td></tr>
<tr class="memdesc:acf59f500385c448b26d0d245f55b23f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing a signed integer type.  <a href="#acf59f500385c448b26d0d245f55b23f4">More...</a><br/></td></tr>
<tr class="separator:acf59f500385c448b26d0d245f55b23f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc1a3eb6d907e515712a228e1d5cbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addc1a3eb6d907e515712a228e1d5cbc9">UInt</a> (int bits, int width=1)</td></tr>
<tr class="memdesc:addc1a3eb6d907e515712a228e1d5cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing an unsigned integer type.  <a href="#addc1a3eb6d907e515712a228e1d5cbc9">More...</a><br/></td></tr>
<tr class="separator:addc1a3eb6d907e515712a228e1d5cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7b9a74aa0b0598f6a37b5137bab68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a63a7b9a74aa0b0598f6a37b5137bab68">Float</a> (int bits, int width=1)</td></tr>
<tr class="memdesc:a63a7b9a74aa0b0598f6a37b5137bab68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a floating-point type.  <a href="#a63a7b9a74aa0b0598f6a37b5137bab68">More...</a><br/></td></tr>
<tr class="separator:a63a7b9a74aa0b0598f6a37b5137bab68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b918730b9d45b139cabdcef54b25773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7b918730b9d45b139cabdcef54b25773">Bool</a> (int width=1)</td></tr>
<tr class="memdesc:a7b918730b9d45b139cabdcef54b25773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean type.  <a href="#a7b918730b9d45b139cabdcef54b25773">More...</a><br/></td></tr>
<tr class="separator:a7b918730b9d45b139cabdcef54b25773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230bbc98235cdeaea250aa9ab19f3312"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230bbc98235cdeaea250aa9ab19f3312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">type_of</a> ()</td></tr>
<tr class="memdesc:a230bbc98235cdeaea250aa9ab19f3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the halide equivalent of a C type.  <a href="#a230bbc98235cdeaea250aa9ab19f3312">More...</a><br/></td></tr>
<tr class="separator:a230bbc98235cdeaea250aa9ab19f3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bff23c8791a8c4c5cd5d3c4bc2fbd"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aef0bff23c8791a8c4c5cd5d3c4bc2fbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aef0bff23c8791a8c4c5cd5d3c4bc2fbd">type_of&lt; float &gt;</a> ()</td></tr>
<tr class="separator:aef0bff23c8791a8c4c5cd5d3c4bc2fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c3c656fc0466cce878419d13e853d3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af5c3c656fc0466cce878419d13e853d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af5c3c656fc0466cce878419d13e853d3">type_of&lt; double &gt;</a> ()</td></tr>
<tr class="separator:af5c3c656fc0466cce878419d13e853d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d5b674a4c433b197c4396f86973b5a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a08d5b674a4c433b197c4396f86973b5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a08d5b674a4c433b197c4396f86973b5a">type_of&lt; unsigned char &gt;</a> ()</td></tr>
<tr class="separator:a08d5b674a4c433b197c4396f86973b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3742da6d65821f2e93ea4eb5918c76"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aca3742da6d65821f2e93ea4eb5918c76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aca3742da6d65821f2e93ea4eb5918c76">type_of&lt; unsigned short &gt;</a> ()</td></tr>
<tr class="separator:aca3742da6d65821f2e93ea4eb5918c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bc8173ace666f6ba1ceef95dd62c97"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a12bc8173ace666f6ba1ceef95dd62c97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a12bc8173ace666f6ba1ceef95dd62c97">type_of&lt; unsigned int &gt;</a> ()</td></tr>
<tr class="separator:a12bc8173ace666f6ba1ceef95dd62c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd980029986aa671a3f2898720f3628"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8bd980029986aa671a3f2898720f3628"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8bd980029986aa671a3f2898720f3628">type_of&lt; bool &gt;</a> ()</td></tr>
<tr class="separator:a8bd980029986aa671a3f2898720f3628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b85b78210894396902023d37d816ea"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad4b85b78210894396902023d37d816ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad4b85b78210894396902023d37d816ea">type_of&lt; char &gt;</a> ()</td></tr>
<tr class="separator:ad4b85b78210894396902023d37d816ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383925ba54651085a17d97ba66a2897a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a383925ba54651085a17d97ba66a2897a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a383925ba54651085a17d97ba66a2897a">type_of&lt; short &gt;</a> ()</td></tr>
<tr class="separator:a383925ba54651085a17d97ba66a2897a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe11e72c65dbaf72e3020887298f16cc"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:afe11e72c65dbaf72e3020887298f16cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afe11e72c65dbaf72e3020887298f16cc">type_of&lt; int &gt;</a> ()</td></tr>
<tr class="separator:afe11e72c65dbaf72e3020887298f16cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3514f233f4753c5c2e8e321066c8fa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abc3514f233f4753c5c2e8e321066c8fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc3514f233f4753c5c2e8e321066c8fa">type_of&lt; signed char &gt;</a> ()</td></tr>
<tr class="separator:abc3514f233f4753c5c2e8e321066c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aad29ce73062fa1887bf57445ad159307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aad29ce73062fa1887bf57445ad159307">sum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:aad29ce73062fa1887bf57445ad159307"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#aad29ce73062fa1887bf57445ad159307">More...</a><br/></td></tr>
<tr class="separator:aad29ce73062fa1887bf57445ad159307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ab2810ee57206e8779d3fbe680ec7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a04ab2810ee57206e8779d3fbe680ec7f">product</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:a04ab2810ee57206e8779d3fbe680ec7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#a04ab2810ee57206e8779d3fbe680ec7f">More...</a><br/></td></tr>
<tr class="separator:a04ab2810ee57206e8779d3fbe680ec7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332a76e7da4224b3bb2cc3df392dd25d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a332a76e7da4224b3bb2cc3df392dd25d">maximum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:a332a76e7da4224b3bb2cc3df392dd25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#a332a76e7da4224b3bb2cc3df392dd25d">More...</a><br/></td></tr>
<tr class="separator:a332a76e7da4224b3bb2cc3df392dd25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7125297ffbdd33138ba22b4f1d471a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abf7125297ffbdd33138ba22b4f1d471a">minimum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:abf7125297ffbdd33138ba22b4f1d471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#abf7125297ffbdd33138ba22b4f1d471a">More...</a><br/></td></tr>
<tr class="separator:abf7125297ffbdd33138ba22b4f1d471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aad29ce73062fa1887bf57445ad159307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sum </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example:</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#aad29ce73062fa1887bf57445ad159307" title="An inline reduction.">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>

</div>
</div>
<a class="anchor" id="a04ab2810ee57206e8779d3fbe680ec7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::product </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example:</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#aad29ce73062fa1887bf57445ad159307" title="An inline reduction.">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>

</div>
</div>
<a class="anchor" id="a332a76e7da4224b3bb2cc3df392dd25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::maximum </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example:</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#aad29ce73062fa1887bf57445ad159307" title="An inline reduction.">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>

</div>
</div>
<a class="anchor" id="abf7125297ffbdd33138ba22b4f1d471a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::minimum </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example:</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#aad29ce73062fa1887bf57445ad159307" title="An inline reduction.">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>

</div>
</div>
<a class="anchor" id="a51c6da1a731c0804063458b531e8a849"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cast </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an expression to the halide type corresponding to the C++ type T. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00124">124</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00129">cast()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00319">clamp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00198">operator*=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00154">operator+=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00181">operator-=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00215">operator/=()</a>.</p>

</div>
</div>
<a class="anchor" id="a69ce0e6da961a52ace4b8fa8444fac20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cast </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an expression to a new type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00129">129</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00115">Halide::Internal::IRHandle::as()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00124">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00057">Halide::Type::element_of()</a>, <a class="el" href="_type_8h_source.html#l00034">Halide::Type::is_scalar()</a>, <a class="el" href="_type_8h_source.html#l00033">Halide::Type::is_vector()</a>, <a class="el" href="_i_r_8h_source.html#l00191">Halide::Internal::Cast::make()</a>, <a class="el" href="_i_r_8h_source.html#l00561">Halide::Internal::Broadcast::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_type_8h_source.html#l00028">Halide::Type::width</a>.</p>

</div>
</div>
<a class="anchor" id="a2db532b84ba55ff72555c4b427fc42bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00145">145</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00205">Halide::Internal::Add::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="acd77e71422999076fa3339829ac8c30d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator+= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the sum of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00154">154</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00124">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, and <a class="el" href="_i_r_8h_source.html#l00205">Halide::Internal::Add::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a86f3eb27005363158ca0e934811c98ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00162">162</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00222">Halide::Internal::Sub::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="a80881209a15ed749e168d6edbcb6f687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the negative of the argument. </p>
<p>Does no type casting, so more formally: return that number which when added to the original, yields zero of the same type. For unsigned integers the negative is still an unsigned integer. E.g. in UInt(8), the negative of 56 is 200, because 56 + 200 == 0 </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00173">173</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00222">Halide::Internal::Sub::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a1dd1e30c6cef3c649310d48d1ec40ec5">Halide::Internal::make_zero()</a>, and <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>.</p>

</div>
</div>
<a class="anchor" id="a94db82f1af5cd7492bb503c2238ade8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator-= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the difference of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00181">181</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00124">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, and <a class="el" href="_i_r_8h_source.html#l00222">Halide::Internal::Sub::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a908c6748ab34a4a66274b196b6900af5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00189">189</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00239">Halide::Internal::Mul::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0c84f284a38d6018e2d4e5d075c8b5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator*= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the product of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00198">198</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00124">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, and <a class="el" href="_i_r_8h_source.html#l00239">Halide::Internal::Mul::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a73e12ddd6395e3a1c1286e2e3c51e675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00206">206</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00256">Halide::Internal::Div::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c0da6820c40a5911fb23d973283487f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator/= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the ratio of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00215">215</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00124">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, and <a class="el" href="_i_r_8h_source.html#l00256">Halide::Internal::Div::make()</a>.</p>

</div>
</div>
<a class="anchor" id="abc191ed3318e2072d18f42d11f5b01d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00223">223</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00275">Halide::Internal::Mod::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="af9105ae9f0995f450825e522170f5d1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00232">232</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00394">Halide::Internal::GT::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="abbad5ee20448455260670dec22c76a21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00241">241</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00360">Halide::Internal::LT::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="ad297e6fa5deb0ba4e8ad7fe344629706"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00250">250</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00377">Halide::Internal::LE::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2e815b9cc7475802c0fb6a7e7ae6ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00260">260</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00411">Halide::Internal::GE::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="abfbbb2e5820938f4d8f0a8b2324776df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00269">269</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00326">Halide::Internal::EQ::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3d11c86964dbb2586103744cac1614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00278">278</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00343">Halide::Internal::NE::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="a02df159d6ed5236cc8e02d04bf72be4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical and of the two arguments. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00285">285</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00428">Halide::Internal::And::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a3528931d7929d533103ada2badca092c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical or of the two arguments. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00290">290</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00446">Halide::Internal::Or::make()</a>.</p>

</div>
</div>
<a class="anchor" id="afb54256bfab344b6720775cf2e0936e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator! </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical not the argument. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00295">295</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00464">Halide::Internal::Not::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a00cabb9f57b4cf5d101b2af338f5ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00302">302</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00309">Halide::Internal::Max::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

</div>
</div>
<a class="anchor" id="a38b5db24ca379dda8241433c0014c940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression representing the lesser of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00311">311</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00292">Halide::Internal::Min::make()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a4dec45d11feb857ae7a021872a055e45">Halide::Internal::match_types()</a>.</p>

<p>Referenced by <a class="el" href="_i_r_8h_source.html#l00810">Halide::Internal::Realize::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a41fc11b69e1ae900cebae51c319a1caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::clamp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamps an expression to lie within the given bounds. </p>
<p>The bounds are type-cast to match the expression. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00319">319</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00124">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00292">Halide::Internal::Min::make()</a>, <a class="el" href="_i_r_8h_source.html#l00309">Halide::Internal::Max::make()</a>, and <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>.</p>

</div>
</div>
<a class="anchor" id="ae698f4bfd37d3d15cee4bf22c4627e0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::abs </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of a signed integer or floating-point expression. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00329">329</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_type_8h_source.html#l00076">Int()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ee021c55c8ca2bdaae9d2dc2000870c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression equivalent to the ternary operator in C. </p>
<p>If the first argument is true, then return the second, else return the third. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00350">350</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00481">Halide::Internal::Select::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1fca22f79625765096133e39caee5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sin </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00356">356</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a3bfc77a80e6b40a6c00899a8e2ad1f28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::asin </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the arcsine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00367">367</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e1ef33189b99c7b8bc73b5e10121834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cos </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cosine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00378">378</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a722a64d3ef272e07177d95b624968951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::acos </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the arccosine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00389">389</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="ad18f43994d3cf73c20b7eb62b243076e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::tan </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tangent of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00400">400</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="abe3b0ec19519602bc880a1ae0236f1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atan </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the arctangent of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00411">411</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="abe05bc670b713a278f8182457a750bd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sinh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic sine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00422">422</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="abb5d3eac37ebfab1c8a2abf7ab1ebfaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::asinh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic arcsinhe of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00433">433</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a68aff5fc199ecbabe209ce32ec507292"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cosh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic cosine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00444">444</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ce048ac6f7c309d26c83fbc3132be2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::acosh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic arccosine of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00455">455</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="acb15a9760067c05d2e5a343f529188be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::tanh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic tangent of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00466">466</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="acd93e33e8d82be7cf9487e881d834ec9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atanh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic arctangent of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00477">477</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="abc7f08f13439b86581a47162e1a2d2de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sqrt </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00488">488</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fb75ff010919c00492e4f654a4d8f85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::hypot </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00499">499</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a877c6187068d6e839e548776dfa7dde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::exp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exponential of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00513">513</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a02f1c38239e6e977fea90b94217499ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::log </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the logarithm of a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00524">524</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="aed670387016322f8db2b7abdecdc0e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::floor </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest whole number less than or equal to a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). The return value is still in floating point, despite being a whole number. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00537">537</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

<p>Referenced by <a class="el" href="_simplify_8h_source.html#l00041">Halide::Internal::mod_imp&lt; double &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a070dde32195d1ae83082c15fd11d5d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::ceil </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the least whole number greater than or equal to a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). The return value is still in floating point, despite being a whole number. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00550">550</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d2090a77072af682d9e2daea086d2fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::round </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the whole number closest to a floating-point expression. </p>
<p>If the argument is not floating-point, is it cast to Float(32). The return value is still in floating point, despite being a whole number. On ties, we round up. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00563">563</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a4dd83996070aa3e4bc3a102a654176fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::pow </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one floating point expression raised to the power of another. </p>
<p>The type of the result is given by the type of the first argument. If the first argument is not a floating-point type, it is cast to Float(32) </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00576">576</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00106">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00094">Float()</a>, <a class="el" href="_i_r_8h_source.html#l00879">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00141">Halide::Expr::type()</a>, and <a class="el" href="_util_8h_source.html#l00038">Halide::Internal::vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a82296f14959ca5344add163ebd60304e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an expression on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a8eecaf53e09386aa3239e758e928a92f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide type on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a57190a14ea6851c5ce46eaedaa77d21a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a zero-dimensional halide function that returns the given expression. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00017">17</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7305aa7d85b97f0900d7f035578ce41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1-D halide function in the first argument that returns the second argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00026">26</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a53bcf8b4f9e47c294dc8eb7f3784fed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 2-D halide function in the first two arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00035">35</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a938729e358e952cd3142850e6307adf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 3-D halide function in the first three arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00044">44</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e105f7398081a2353df028af3ca79a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 4-D halide function in the first four arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00053">53</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a526ddeb0daa2a8445c23381817eea573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RVar&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a4ccef6c4dd64764e831b56cd14e410c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="acf59f500385c448b26d0d245f55b23f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing a signed integer type. </p>

<p>Definition at line <a class="el" href="_type_8h_source.html#l00076">76</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00025">Halide::Type::bits</a>, <a class="el" href="_type_8h_source.html#l00019">Halide::Type::Int</a>, <a class="el" href="struct_halide_1_1_type.html#ad8b053cd9de299f4309240d83b69e24f">Halide::Type::t</a>, and <a class="el" href="_type_8h_source.html#l00028">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00329">abs()</a>, <a class="el" href="_param_8h_source.html#l00116">Halide::ImageParam::extent()</a>, <a class="el" href="_i_r_8h_source.html#l00167">Halide::Internal::IntImm::make()</a>, <a class="el" href="_var_8h_source.html#l00114">Halide::Var::operator Expr()</a>, <a class="el" href="_param_8h_source.html#l00124">Halide::ImageParam::stride()</a>, <a class="el" href="_type_8h_source.html#l00116">type_of&lt; char &gt;()</a>, <a class="el" href="_type_8h_source.html#l00118">type_of&lt; int &gt;()</a>, <a class="el" href="_type_8h_source.html#l00117">type_of&lt; short &gt;()</a>, and <a class="el" href="_type_8h_source.html#l00119">type_of&lt; signed char &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="addc1a3eb6d907e515712a228e1d5cbc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::UInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing an unsigned integer type. </p>

<p>Definition at line <a class="el" href="_type_8h_source.html#l00085">85</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00025">Halide::Type::bits</a>, <a class="el" href="struct_halide_1_1_type.html#ad8b053cd9de299f4309240d83b69e24f">Halide::Type::t</a>, <a class="el" href="_type_8h_source.html#l00020">Halide::Type::UInt</a>, and <a class="el" href="_type_8h_source.html#l00028">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_type_8h_source.html#l00103">Bool()</a>, <a class="el" href="_type_8h_source.html#l00112">type_of&lt; unsigned char &gt;()</a>, <a class="el" href="_type_8h_source.html#l00114">type_of&lt; unsigned int &gt;()</a>, and <a class="el" href="_type_8h_source.html#l00113">type_of&lt; unsigned short &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a63a7b9a74aa0b0598f6a37b5137bab68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Float </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a floating-point type. </p>

<p>Definition at line <a class="el" href="_type_8h_source.html#l00094">94</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00025">Halide::Type::bits</a>, <a class="el" href="_type_8h_source.html#l00021">Halide::Type::Float</a>, <a class="el" href="struct_halide_1_1_type.html#ad8b053cd9de299f4309240d83b69e24f">Halide::Type::t</a>, and <a class="el" href="_type_8h_source.html#l00028">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00329">abs()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00389">acos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00455">acosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00367">asin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00433">asinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00411">atan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00477">atanh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00550">ceil()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00378">cos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00444">cosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00513">exp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00537">floor()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00499">hypot()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00524">log()</a>, <a class="el" href="_i_r_8h_source.html#l00179">Halide::Internal::FloatImm::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00576">pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00563">round()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00356">sin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00422">sinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00488">sqrt()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00400">tan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00466">tanh()</a>, <a class="el" href="_type_8h_source.html#l00111">type_of&lt; double &gt;()</a>, and <a class="el" href="_type_8h_source.html#l00110">type_of&lt; float &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b918730b9d45b139cabdcef54b25773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Bool </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a boolean type. </p>

<p>Definition at line <a class="el" href="_type_8h_source.html#l00103">103</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00085">UInt()</a>.</p>

<p>Referenced by <a class="el" href="_i_r_8h_source.html#l00326">Halide::Internal::EQ::make()</a>, <a class="el" href="_i_r_8h_source.html#l00343">Halide::Internal::NE::make()</a>, <a class="el" href="_i_r_8h_source.html#l00360">Halide::Internal::LT::make()</a>, <a class="el" href="_i_r_8h_source.html#l00377">Halide::Internal::LE::make()</a>, <a class="el" href="_i_r_8h_source.html#l00394">Halide::Internal::GT::make()</a>, <a class="el" href="_i_r_8h_source.html#l00411">Halide::Internal::GE::make()</a>, <a class="el" href="_i_r_8h_source.html#l00428">Halide::Internal::And::make()</a>, <a class="el" href="_i_r_8h_source.html#l00446">Halide::Internal::Or::make()</a>, <a class="el" href="_i_r_8h_source.html#l00464">Halide::Internal::Not::make()</a>, and <a class="el" href="_type_8h_source.html#l00115">type_of&lt; bool &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a230bbc98235cdeaea250aa9ab19f3312"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::type_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the halide equivalent of a C type. </p>

</div>
</div>
<a class="anchor" id="aef0bff23c8791a8c4c5cd5d3c4bc2fbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00110">110</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00094">Float()</a>.</p>

</div>
</div>
<a class="anchor" id="af5c3c656fc0466cce878419d13e853d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00111">111</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00094">Float()</a>.</p>

</div>
</div>
<a class="anchor" id="a08d5b674a4c433b197c4396f86973b5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; unsigned char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00112">112</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00085">UInt()</a>.</p>

</div>
</div>
<a class="anchor" id="aca3742da6d65821f2e93ea4eb5918c76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; unsigned short &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00113">113</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00085">UInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a12bc8173ace666f6ba1ceef95dd62c97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; unsigned int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00114">114</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00085">UInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd980029986aa671a3f2898720f3628"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00115">115</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00103">Bool()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4b85b78210894396902023d37d816ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00116">116</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00076">Int()</a>.</p>

</div>
</div>
<a class="anchor" id="a383925ba54651085a17d97ba66a2897a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; short &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00117">117</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00076">Int()</a>.</p>

</div>
</div>
<a class="anchor" id="afe11e72c65dbaf72e3020887298f16cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00118">118</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00076">Int()</a>.</p>

</div>
</div>
<a class="anchor" id="abc3514f233f4753c5c2e8e321066c8fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">Halide::type_of</a>&lt; signed char &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_type_8h_source.html#l00119">119</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00076">Int()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li>
    <li class="footer">Generated on Wed May 29 2013 16:11:50 for Halide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
