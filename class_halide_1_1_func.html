<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Halide: Halide::Func Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_func.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_halide_1_1_func-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Func Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A halide function.  
 <a href="class_halide_1_1_func.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a265d4e8c8c6225fb5455f4b6c3496db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a265d4e8c8c6225fb5455f4b6c3496db0">Func</a> (const std::string &amp;<a class="el" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8">name</a>)</td></tr>
<tr class="memdesc:a265d4e8c8c6225fb5455f4b6c3496db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with the given name.  <a href="#a265d4e8c8c6225fb5455f4b6c3496db0">More...</a><br/></td></tr>
<tr class="separator:a265d4e8c8c6225fb5455f4b6c3496db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed876d44c3e1dd0a72c4111afc63018b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b">Func</a> ()</td></tr>
<tr class="memdesc:aed876d44c3e1dd0a72c4111afc63018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with an automatically-generated unique name.  <a href="#aed876d44c3e1dd0a72c4111afc63018b">More...</a><br/></td></tr>
<tr class="separator:aed876d44c3e1dd0a72c4111afc63018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aa00c3ee27c264979fd1b90f271085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a89aa00c3ee27c264979fd1b90f271085">Func</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a89aa00c3ee27c264979fd1b90f271085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new function with an automatically-generated unique name, and define it to return the given expression (which may not contain free variables).  <a href="#a89aa00c3ee27c264979fd1b90f271085">More...</a><br/></td></tr>
<tr class="separator:a89aa00c3ee27c264979fd1b90f271085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa304976dc9e5cd003a4c77409287e180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa304976dc9e5cd003a4c77409287e180">realize</a> (int x_size=0, int y_size=0, int z_size=0, int w_size=0)</td></tr>
<tr class="memdesc:aa304976dc9e5cd003a4c77409287e180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new uniquely-named function that returns the given buffer.  <a href="#aa304976dc9e5cd003a4c77409287e180">More...</a><br/></td></tr>
<tr class="separator:aa304976dc9e5cd003a4c77409287e180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a033e71f69cdfbf9f0329b2adc05c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a50a033e71f69cdfbf9f0329b2adc05c1">realize</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> dst)</td></tr>
<tr class="memdesc:a50a033e71f69cdfbf9f0329b2adc05c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer.  <a href="#a50a033e71f69cdfbf9f0329b2adc05c1">More...</a><br/></td></tr>
<tr class="separator:a50a033e71f69cdfbf9f0329b2adc05c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1766b2c9fe767ebe835b807db8b73cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af1766b2c9fe767ebe835b807db8b73cf">compile_to_bitcode</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;)</td></tr>
<tr class="memdesc:af1766b2c9fe767ebe835b807db8b73cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#af1766b2c9fe767ebe835b807db8b73cf">More...</a><br/></td></tr>
<tr class="separator:af1766b2c9fe767ebe835b807db8b73cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ad88b379adececdd34bdfbc9c0fd2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a38ad88b379adececdd34bdfbc9c0fd2d">compile_to_object</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a38ad88b379adececdd34bdfbc9c0fd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#a38ad88b379adececdd34bdfbc9c0fd2d">More...</a><br/></td></tr>
<tr class="separator:a38ad88b379adececdd34bdfbc9c0fd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9623ffff43b170735b65c490b68ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aae9623ffff43b170735b65c490b68ffb">compile_to_header</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;)</td></tr>
<tr class="memdesc:aae9623ffff43b170735b65c490b68ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a header file with the given filename for this function.  <a href="#aae9623ffff43b170735b65c490b68ffb">More...</a><br/></td></tr>
<tr class="separator:aae9623ffff43b170735b65c490b68ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d16f8fb285adf13ec7c10ff5bc1a4bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a2d16f8fb285adf13ec7c10ff5bc1a4bf">compile_to_assembly</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a2d16f8fb285adf13ec7c10ff5bc1a4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to text assembly equivalent to the object file generated by compile_to_object.  <a href="#a2d16f8fb285adf13ec7c10ff5bc1a4bf">More...</a><br/></td></tr>
<tr class="separator:a2d16f8fb285adf13ec7c10ff5bc1a4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a6c208a0d447cb9e28c088d138e0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a04a6c208a0d447cb9e28c088d138e0a5">compile_to_c</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a04a6c208a0d447cb9e28c088d138e0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to C source code.  <a href="#a04a6c208a0d447cb9e28c088d138e0a5">More...</a><br/></td></tr>
<tr class="separator:a04a6c208a0d447cb9e28c088d138e0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d7d8baab31e6e34f6862cb653b66f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a43d7d8baab31e6e34f6862cb653b66f4">compile_jit</a> ()</td></tr>
<tr class="memdesc:a43d7d8baab31e6e34f6862cb653b66f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly jit compile the function to machine code.  <a href="#a43d7d8baab31e6e34f6862cb653b66f4">More...</a><br/></td></tr>
<tr class="separator:a43d7d8baab31e6e34f6862cb653b66f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785ff1f13e2c194280e6dd9db17c0a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a785ff1f13e2c194280e6dd9db17c0a15">set_error_handler</a> (void(*handler)(char *))</td></tr>
<tr class="memdesc:a785ff1f13e2c194280e6dd9db17c0a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error handler function that be called in the case of runtime errors during halide pipelines.  <a href="#a785ff1f13e2c194280e6dd9db17c0a15">More...</a><br/></td></tr>
<tr class="separator:a785ff1f13e2c194280e6dd9db17c0a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08dcceb9c5fb0205815c52100327f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab08dcceb9c5fb0205815c52100327f47">set_custom_allocator</a> (void *(*malloc)(size_t), void(*free)(void *))</td></tr>
<tr class="memdesc:ab08dcceb9c5fb0205815c52100327f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom malloc and free for halide to use.  <a href="#ab08dcceb9c5fb0205815c52100327f47">More...</a><br/></td></tr>
<tr class="separator:ab08dcceb9c5fb0205815c52100327f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a4c3f59b390c6766650351c69b945f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a32a4c3f59b390c6766650351c69b945f">set_custom_do_task</a> (void(*custom_do_task)(void(*)(int, uint8_t *), int, uint8_t *))</td></tr>
<tr class="memdesc:a32a4c3f59b390c6766650351c69b945f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom task handler to be called by the parallel for loop.  <a href="#a32a4c3f59b390c6766650351c69b945f">More...</a><br/></td></tr>
<tr class="separator:a32a4c3f59b390c6766650351c69b945f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6e8bec521c66b8621d1fa8bd405576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a3b6e8bec521c66b8621d1fa8bd405576">set_custom_do_par_for</a> (void(*custom_do_par_for)(void(*)(int, uint8_t *), int, int, uint8_t *))</td></tr>
<tr class="memdesc:a3b6e8bec521c66b8621d1fa8bd405576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom parallel for loop launcher.  <a href="#a3b6e8bec521c66b8621d1fa8bd405576">More...</a><br/></td></tr>
<tr class="separator:a3b6e8bec521c66b8621d1fa8bd405576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad698122392e50574c38e3d19b0c9c41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad698122392e50574c38e3d19b0c9c41e">debug_to_file</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ad698122392e50574c38e3d19b0c9c41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this function is compiled, include code that dumps its values to a file after it is realized, for the purpose of debugging.  <a href="#ad698122392e50574c38e3d19b0c9c41e">More...</a><br/></td></tr>
<tr class="separator:ad698122392e50574c38e3d19b0c9c41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c36026717d2f74a842983d65e6b3bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8">name</a> () const </td></tr>
<tr class="memdesc:a1c36026717d2f74a842983d65e6b3bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this function, either given during construction, or automatically generated.  <a href="#a1c36026717d2f74a842983d65e6b3bf8">More...</a><br/></td></tr>
<tr class="separator:a1c36026717d2f74a842983d65e6b3bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184f385b265e7ba488a2eed66a10b41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a184f385b265e7ba488a2eed66a10b41a">value</a> () const </td></tr>
<tr class="memdesc:a184f385b265e7ba488a2eed66a10b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The right-hand-side value of the pure definition of this function.  <a href="#a184f385b265e7ba488a2eed66a10b41a">More...</a><br/></td></tr>
<tr class="separator:a184f385b265e7ba488a2eed66a10b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8993a73f9eb2d0c7ccc58028447d42f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a8993a73f9eb2d0c7ccc58028447d42f3">dimensions</a> () const </td></tr>
<tr class="memdesc:a8993a73f9eb2d0c7ccc58028447d42f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality (number of arguments) of this function.  <a href="#a8993a73f9eb2d0c7ccc58028447d42f3">More...</a><br/></td></tr>
<tr class="separator:a8993a73f9eb2d0c7ccc58028447d42f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11de589971243d53709563789ef09273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a11de589971243d53709563789ef09273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute this function as needed for each unique value of the given var for the given calling function f.  <a href="#a11de589971243d53709563789ef09273">More...</a><br/></td></tr>
<tr class="separator:a11de589971243d53709563789ef09273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf97325c7449720d8d84115353a2c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#addf97325c7449720d8d84115353a2c7d">compute_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_r_var.html">RVar</a> var)</td></tr>
<tr class="memdesc:addf97325c7449720d8d84115353a2c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a function to be computed within the iteration over some dimension of a reduction domain.  <a href="#addf97325c7449720d8d84115353a2c7d">More...</a><br/></td></tr>
<tr class="separator:addf97325c7449720d8d84115353a2c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4db7e4884fe76399bf2a673567eab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7f4db7e4884fe76399bf2a673567eab5">compute_root</a> ()</td></tr>
<tr class="memdesc:a7f4db7e4884fe76399bf2a673567eab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all of this function once ahead of time.  <a href="#a7f4db7e4884fe76399bf2a673567eab5">More...</a><br/></td></tr>
<tr class="separator:a7f4db7e4884fe76399bf2a673567eab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb0d00bc9585bf3027011ecb1412b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">store_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a33cb0d00bc9585bf3027011ecb1412b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for this function within f's loop over var.  <a href="#a33cb0d00bc9585bf3027011ecb1412b7">More...</a><br/></td></tr>
<tr class="separator:a33cb0d00bc9585bf3027011ecb1412b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61980a1317bdbd1017f284414865deac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a61980a1317bdbd1017f284414865deac">store_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_r_var.html">RVar</a> var)</td></tr>
<tr class="memdesc:a61980a1317bdbd1017f284414865deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain.  <a href="#a61980a1317bdbd1017f284414865deac">More...</a><br/></td></tr>
<tr class="separator:a61980a1317bdbd1017f284414865deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7048eaf680bc0c78961c0bef48d37f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85">store_root</a> ()</td></tr>
<tr class="memdesc:a7048eaf680bc0c78961c0bef48d37f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">Func::store_at</a>, but schedules storage outside the outermost loop.  <a href="#a7048eaf680bc0c78961c0bef48d37f85">More...</a><br/></td></tr>
<tr class="separator:a7048eaf680bc0c78961c0bef48d37f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b824c681a83aba8e318652bade047dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6b824c681a83aba8e318652bade047dc">compute_inline</a> ()</td></tr>
<tr class="memdesc:a6b824c681a83aba8e318652bade047dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressively inline all uses of this function.  <a href="#a6b824c681a83aba8e318652bade047dc">More...</a><br/></td></tr>
<tr class="separator:a6b824c681a83aba8e318652bade047dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac11539aa8f54ae551f34b79bc68d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#acac11539aa8f54ae551f34b79bc68d19">update</a> ()</td></tr>
<tr class="memdesc:acac11539aa8f54ae551f34b79bc68d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the update step of a reduction for the purposes of scheduling it.  <a href="#acac11539aa8f54ae551f34b79bc68d19">More...</a><br/></td></tr>
<tr class="separator:acac11539aa8f54ae551f34b79bc68d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53d44302c15c4335e55a2887e2f780e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af53d44302c15c4335e55a2887e2f780e">function</a> () const </td></tr>
<tr class="memdesc:af53d44302c15c4335e55a2887e2f780e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the internal halide function that this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> represents.  <a href="#af53d44302c15c4335e55a2887e2f780e">More...</a><br/></td></tr>
<tr class="separator:af53d44302c15c4335e55a2887e2f780e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30b03fbc4252d7e3c4baa63feedf8bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af30b03fbc4252d7e3c4baa63feedf8bd">operator Expr</a> () const </td></tr>
<tr class="memdesc:af30b03fbc4252d7e3c4baa63feedf8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting a function to an expression is equivalent to calling the function with zero arguments.  <a href="#af30b03fbc4252d7e3c4baa63feedf8bd">More...</a><br/></td></tr>
<tr class="separator:af30b03fbc4252d7e3c4baa63feedf8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b971607afe7e65e121f43510554aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a351b971607afe7e65e121f43510554aa">operator=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a351b971607afe7e65e121f43510554aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to take a number of arguments according to the implicit variables present in the given expression, and return the given expression.  <a href="#a351b971607afe7e65e121f43510554aa">More...</a><br/></td></tr>
<tr class="separator:a351b971607afe7e65e121f43510554aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9069edd2d55144f818c4ceb612d22b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa9069edd2d55144f818c4ceb612d22b7">operator=</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f)</td></tr>
<tr class="memdesc:aa9069edd2d55144f818c4ceb612d22b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function to simply call another function.  <a href="#aa9069edd2d55144f818c4ceb612d22b7">More...</a><br/></td></tr>
<tr class="separator:aa9069edd2d55144f818c4ceb612d22b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a68c638e672ab03f4c6d33b3d18a38bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a68c638e672ab03f4c6d33b3d18a38bd1">compile_to_file</a> (const std::string &amp;filename_prefix, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; args)</td></tr>
<tr class="memdesc:a68c638e672ab03f4c6d33b3d18a38bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a68c638e672ab03f4c6d33b3d18a38bd1">More...</a><br/></td></tr>
<tr class="separator:a68c638e672ab03f4c6d33b3d18a38bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad298bdaa8046ed536fb0caa41b8afed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad298bdaa8046ed536fb0caa41b8afed0">compile_to_file</a> (const std::string &amp;filename_prefix)</td></tr>
<tr class="memdesc:ad298bdaa8046ed536fb0caa41b8afed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#ad298bdaa8046ed536fb0caa41b8afed0">More...</a><br/></td></tr>
<tr class="separator:ad298bdaa8046ed536fb0caa41b8afed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d70781dcc8d7ce235afb03671f1b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac3d70781dcc8d7ce235afb03671f1b1f">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a)</td></tr>
<tr class="memdesc:ac3d70781dcc8d7ce235afb03671f1b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#ac3d70781dcc8d7ce235afb03671f1b1f">More...</a><br/></td></tr>
<tr class="separator:ac3d70781dcc8d7ce235afb03671f1b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad32263aeca597b89ef1a4c2f21d6daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aad32263aeca597b89ef1a4c2f21d6daf">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b)</td></tr>
<tr class="memdesc:aad32263aeca597b89ef1a4c2f21d6daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#aad32263aeca597b89ef1a4c2f21d6daf">More...</a><br/></td></tr>
<tr class="separator:aad32263aeca597b89ef1a4c2f21d6daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaee49e35c41c750493ed4c54fa6e328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afaee49e35c41c750493ed4c54fa6e328">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> c)</td></tr>
<tr class="memdesc:afaee49e35c41c750493ed4c54fa6e328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#afaee49e35c41c750493ed4c54fa6e328">More...</a><br/></td></tr>
<tr class="separator:afaee49e35c41c750493ed4c54fa6e328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ae1dcf2cacf172217cb9f895881f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a65ae1dcf2cacf172217cb9f895881f05">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> c, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> d)</td></tr>
<tr class="memdesc:a65ae1dcf2cacf172217cb9f895881f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a65ae1dcf2cacf172217cb9f895881f05">More...</a><br/></td></tr>
<tr class="separator:a65ae1dcf2cacf172217cb9f895881f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ce3192ec9a6840d312b97667552c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a464ce3192ec9a6840d312b97667552c0">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> c, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> d, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> e)</td></tr>
<tr class="memdesc:a464ce3192ec9a6840d312b97667552c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a464ce3192ec9a6840d312b97667552c0">More...</a><br/></td></tr>
<tr class="separator:a464ce3192ec9a6840d312b97667552c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afb028626864f2a3f39641d00af78910f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f">operator()</a> () const </td></tr>
<tr class="memdesc:afb028626864f2a3f39641d00af78910f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#afb028626864f2a3f39641d00af78910f">More...</a><br/></td></tr>
<tr class="separator:afb028626864f2a3f39641d00af78910f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce0f0c6d8463c32f9ceacb0fe045051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6ce0f0c6d8463c32f9ceacb0fe045051">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x) const </td></tr>
<tr class="memdesc:a6ce0f0c6d8463c32f9ceacb0fe045051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#a6ce0f0c6d8463c32f9ceacb0fe045051">More...</a><br/></td></tr>
<tr class="separator:a6ce0f0c6d8463c32f9ceacb0fe045051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a31dc608a3f44d6aadb2a6edc8f7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a60a31dc608a3f44d6aadb2a6edc8f7e1">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y) const </td></tr>
<tr class="memdesc:a60a31dc608a3f44d6aadb2a6edc8f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#a60a31dc608a3f44d6aadb2a6edc8f7e1">More...</a><br/></td></tr>
<tr class="separator:a60a31dc608a3f44d6aadb2a6edc8f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a51dc115473368299e9966979e530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0f2a51dc115473368299e9966979e530">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z) const </td></tr>
<tr class="memdesc:a0f2a51dc115473368299e9966979e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#a0f2a51dc115473368299e9966979e530">More...</a><br/></td></tr>
<tr class="separator:a0f2a51dc115473368299e9966979e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64144c733800b0b6bc0f1d8108e2ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af64144c733800b0b6bc0f1d8108e2ddc">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w) const </td></tr>
<tr class="memdesc:af64144c733800b0b6bc0f1d8108e2ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#af64144c733800b0b6bc0f1d8108e2ddc">More...</a><br/></td></tr>
<tr class="separator:af64144c733800b0b6bc0f1d8108e2ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd2a13dff2a024e86445e56c719503a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aafd2a13dff2a024e86445e56c719503a">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> u) const </td></tr>
<tr class="memdesc:aafd2a13dff2a024e86445e56c719503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#aafd2a13dff2a024e86445e56c719503a">More...</a><br/></td></tr>
<tr class="separator:aafd2a13dff2a024e86445e56c719503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad155774acf0b530a7bf1fb5f1b513c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad155774acf0b530a7bf1fb5f1b513c16">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> u, <a class="el" href="class_halide_1_1_var.html">Var</a> v) const </td></tr>
<tr class="memdesc:ad155774acf0b530a7bf1fb5f1b513c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#ad155774acf0b530a7bf1fb5f1b513c16">More...</a><br/></td></tr>
<tr class="separator:ad155774acf0b530a7bf1fb5f1b513c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae126902d07bdf0bb9595ef9c36ce857c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae126902d07bdf0bb9595ef9c36ce857c">operator()</a> (std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;) const </td></tr>
<tr class="memdesc:ae126902d07bdf0bb9595ef9c36ce857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#ae126902d07bdf0bb9595ef9c36ce857c">More...</a><br/></td></tr>
<tr class="separator:ae126902d07bdf0bb9595ef9c36ce857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a85c51b6c4753623f6c85d067bbe367ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a85c51b6c4753623f6c85d067bbe367ff">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x) const </td></tr>
<tr class="memdesc:a85c51b6c4753623f6c85d067bbe367ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a85c51b6c4753623f6c85d067bbe367ff">More...</a><br/></td></tr>
<tr class="separator:a85c51b6c4753623f6c85d067bbe367ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37eb8a056b41e7983fc7127471c1350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae37eb8a056b41e7983fc7127471c1350">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y) const </td></tr>
<tr class="memdesc:ae37eb8a056b41e7983fc7127471c1350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#ae37eb8a056b41e7983fc7127471c1350">More...</a><br/></td></tr>
<tr class="separator:ae37eb8a056b41e7983fc7127471c1350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5159835278ac904ee9512608d2acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a27b5159835278ac904ee9512608d2acb">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z) const </td></tr>
<tr class="memdesc:a27b5159835278ac904ee9512608d2acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a27b5159835278ac904ee9512608d2acb">More...</a><br/></td></tr>
<tr class="separator:a27b5159835278ac904ee9512608d2acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2722b4f2538ddc74a966419d13b73b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a2722b4f2538ddc74a966419d13b73b2f">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> w) const </td></tr>
<tr class="memdesc:a2722b4f2538ddc74a966419d13b73b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a2722b4f2538ddc74a966419d13b73b2f">More...</a><br/></td></tr>
<tr class="separator:a2722b4f2538ddc74a966419d13b73b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ae313b5ed4cd15232e85d2901cb97f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a16ae313b5ed4cd15232e85d2901cb97f">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> w, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> u) const </td></tr>
<tr class="memdesc:a16ae313b5ed4cd15232e85d2901cb97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a16ae313b5ed4cd15232e85d2901cb97f">More...</a><br/></td></tr>
<tr class="separator:a16ae313b5ed4cd15232e85d2901cb97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31299fe9c9d0c7e3ba7e34be4e8df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6b31299fe9c9d0c7e3ba7e34be4e8df5">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> w, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> u, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v) const </td></tr>
<tr class="memdesc:a6b31299fe9c9d0c7e3ba7e34be4e8df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a6b31299fe9c9d0c7e3ba7e34be4e8df5">More...</a><br/></td></tr>
<tr class="separator:a6b31299fe9c9d0c7e3ba7e34be4e8df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86c1602915f8a423faf62926201ad9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac86c1602915f8a423faf62926201ad9a">operator()</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;) const </td></tr>
<tr class="memdesc:ac86c1602915f8a423faf62926201ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#ac86c1602915f8a423faf62926201ad9a">More...</a><br/></td></tr>
<tr class="separator:ac86c1602915f8a423faf62926201ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abefe6262e23d34d161c7cc0b85e07187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#abefe6262e23d34d161c7cc0b85e07187">split</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> old, <a class="el" href="class_halide_1_1_var.html">Var</a> outer, <a class="el" href="class_halide_1_1_var.html">Var</a> inner, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> factor)</td></tr>
<tr class="memdesc:abefe6262e23d34d161c7cc0b85e07187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#abefe6262e23d34d161c7cc0b85e07187">More...</a><br/></td></tr>
<tr class="separator:abefe6262e23d34d161c7cc0b85e07187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ee31a00e40c4531af6f58187ee19b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a93ee31a00e40c4531af6f58187ee19b9">parallel</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a93ee31a00e40c4531af6f58187ee19b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a93ee31a00e40c4531af6f58187ee19b9">More...</a><br/></td></tr>
<tr class="separator:a93ee31a00e40c4531af6f58187ee19b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbde565654302d9c0ab9383a0e42708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1cbde565654302d9c0ab9383a0e42708">vectorize</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:a1cbde565654302d9c0ab9383a0e42708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a1cbde565654302d9c0ab9383a0e42708">More...</a><br/></td></tr>
<tr class="separator:a1cbde565654302d9c0ab9383a0e42708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0055492c3b10965e1656f26431a01d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab0055492c3b10965e1656f26431a01d8">unroll</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr class="memdesc:ab0055492c3b10965e1656f26431a01d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#ab0055492c3b10965e1656f26431a01d8">More...</a><br/></td></tr>
<tr class="separator:ab0055492c3b10965e1656f26431a01d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34111b1eb2321cbde1515e307239df7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a34111b1eb2321cbde1515e307239df7a">vectorize</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, int factor)</td></tr>
<tr class="memdesc:a34111b1eb2321cbde1515e307239df7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a34111b1eb2321cbde1515e307239df7a">More...</a><br/></td></tr>
<tr class="separator:a34111b1eb2321cbde1515e307239df7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b181aa119bcf7319892a3bc060fcf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a46b181aa119bcf7319892a3bc060fcf4">unroll</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, int factor)</td></tr>
<tr class="memdesc:a46b181aa119bcf7319892a3bc060fcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a46b181aa119bcf7319892a3bc060fcf4">More...</a><br/></td></tr>
<tr class="separator:a46b181aa119bcf7319892a3bc060fcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadd04bc51ed5999496eaa876a4ee790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afadd04bc51ed5999496eaa876a4ee790">bound</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr class="memdesc:afadd04bc51ed5999496eaa876a4ee790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#afadd04bc51ed5999496eaa876a4ee790">More...</a><br/></td></tr>
<tr class="separator:afadd04bc51ed5999496eaa876a4ee790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070bb51c52383bd6402d6002458a3788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a070bb51c52383bd6402d6002458a3788">tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> xo, <a class="el" href="class_halide_1_1_var.html">Var</a> yo, <a class="el" href="class_halide_1_1_var.html">Var</a> xi, <a class="el" href="class_halide_1_1_var.html">Var</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr class="memdesc:a070bb51c52383bd6402d6002458a3788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a070bb51c52383bd6402d6002458a3788">More...</a><br/></td></tr>
<tr class="separator:a070bb51c52383bd6402d6002458a3788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36a87a19b09e4a195afe3dce519cb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab36a87a19b09e4a195afe3dce519cb63">tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> xi, <a class="el" href="class_halide_1_1_var.html">Var</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr class="memdesc:ab36a87a19b09e4a195afe3dce519cb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#ab36a87a19b09e4a195afe3dce519cb63">More...</a><br/></td></tr>
<tr class="separator:ab36a87a19b09e4a195afe3dce519cb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcab053b6cbebab50704aa82057a9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6fcab053b6cbebab50704aa82057a9eb">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y)</td></tr>
<tr class="memdesc:a6fcab053b6cbebab50704aa82057a9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a6fcab053b6cbebab50704aa82057a9eb">More...</a><br/></td></tr>
<tr class="separator:a6fcab053b6cbebab50704aa82057a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e224ddf7cb7a6c72aa98ee97401716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab2e224ddf7cb7a6c72aa98ee97401716">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z)</td></tr>
<tr class="memdesc:ab2e224ddf7cb7a6c72aa98ee97401716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#ab2e224ddf7cb7a6c72aa98ee97401716">More...</a><br/></td></tr>
<tr class="separator:ab2e224ddf7cb7a6c72aa98ee97401716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29cec9650d4d53f304ff737d68f13c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac29cec9650d4d53f304ff737d68f13c6">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w)</td></tr>
<tr class="memdesc:ac29cec9650d4d53f304ff737d68f13c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#ac29cec9650d4d53f304ff737d68f13c6">More...</a><br/></td></tr>
<tr class="separator:ac29cec9650d4d53f304ff737d68f13c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86876a3812c3e74a6993b03825e18d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a86876a3812c3e74a6993b03825e18d03">reorder</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t)</td></tr>
<tr class="memdesc:a86876a3812c3e74a6993b03825e18d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a86876a3812c3e74a6993b03825e18d03">More...</a><br/></td></tr>
<tr class="separator:a86876a3812c3e74a6993b03825e18d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fc932b2a8be41af352c39f3128c74c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad7fc932b2a8be41af352c39f3128c74c">rename</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> old_name, <a class="el" href="class_halide_1_1_var.html">Var</a> new_name)</td></tr>
<tr class="memdesc:ad7fc932b2a8be41af352c39f3128c74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#ad7fc932b2a8be41af352c39f3128c74c">More...</a><br/></td></tr>
<tr class="separator:ad7fc932b2a8be41af352c39f3128c74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025fbc02ba21775bc17665d2a29c017c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a025fbc02ba21775bc17665d2a29c017c">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x)</td></tr>
<tr class="memdesc:a025fbc02ba21775bc17665d2a29c017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a025fbc02ba21775bc17665d2a29c017c">More...</a><br/></td></tr>
<tr class="separator:a025fbc02ba21775bc17665d2a29c017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1f253d87e6052e39a6e672d8ddb7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a8e1f253d87e6052e39a6e672d8ddb7e0">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y)</td></tr>
<tr class="memdesc:a8e1f253d87e6052e39a6e672d8ddb7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a8e1f253d87e6052e39a6e672d8ddb7e0">More...</a><br/></td></tr>
<tr class="separator:a8e1f253d87e6052e39a6e672d8ddb7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48f5e79415eda6f01539dc0fc9ba05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa48f5e79415eda6f01539dc0fc9ba05a">cuda_threads</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_z)</td></tr>
<tr class="memdesc:aa48f5e79415eda6f01539dc0fc9ba05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#aa48f5e79415eda6f01539dc0fc9ba05a">More...</a><br/></td></tr>
<tr class="separator:aa48f5e79415eda6f01539dc0fc9ba05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94deb0bfb7286bf794cc0dcf00040a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a94deb0bfb7286bf794cc0dcf00040a5d">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x)</td></tr>
<tr class="memdesc:a94deb0bfb7286bf794cc0dcf00040a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a94deb0bfb7286bf794cc0dcf00040a5d">More...</a><br/></td></tr>
<tr class="separator:a94deb0bfb7286bf794cc0dcf00040a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e05993bf55b53825d1c036804aa05db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1e05993bf55b53825d1c036804aa05db">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y)</td></tr>
<tr class="memdesc:a1e05993bf55b53825d1c036804aa05db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a1e05993bf55b53825d1c036804aa05db">More...</a><br/></td></tr>
<tr class="separator:a1e05993bf55b53825d1c036804aa05db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50627066af66b070ce7f0515c733c4a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a50627066af66b070ce7f0515c733c4a5">cuda_blocks</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> block_z)</td></tr>
<tr class="memdesc:a50627066af66b070ce7f0515c733c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a50627066af66b070ce7f0515c733c4a5">More...</a><br/></td></tr>
<tr class="separator:a50627066af66b070ce7f0515c733c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970910f3fa8dd312cadf0b848eec1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a9970910f3fa8dd312cadf0b848eec1fc">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x)</td></tr>
<tr class="memdesc:a9970910f3fa8dd312cadf0b848eec1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a9970910f3fa8dd312cadf0b848eec1fc">More...</a><br/></td></tr>
<tr class="separator:a9970910f3fa8dd312cadf0b848eec1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251b2c0835d9ac9384729fe83d0b3ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a251b2c0835d9ac9384729fe83d0b3ea4">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y)</td></tr>
<tr class="memdesc:a251b2c0835d9ac9384729fe83d0b3ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a251b2c0835d9ac9384729fe83d0b3ea4">More...</a><br/></td></tr>
<tr class="separator:a251b2c0835d9ac9384729fe83d0b3ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62623f10f29023c1bd6b871ad9ede757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a62623f10f29023c1bd6b871ad9ede757">cuda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> block_x, <a class="el" href="class_halide_1_1_var.html">Var</a> block_y, <a class="el" href="class_halide_1_1_var.html">Var</a> block_z, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_x, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_y, <a class="el" href="class_halide_1_1_var.html">Var</a> thread_z)</td></tr>
<tr class="memdesc:a62623f10f29023c1bd6b871ad9ede757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a62623f10f29023c1bd6b871ad9ede757">More...</a><br/></td></tr>
<tr class="separator:a62623f10f29023c1bd6b871ad9ede757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e21fd647773e3fcbeedd137b520580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af1e21fd647773e3fcbeedd137b520580">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, int x_size)</td></tr>
<tr class="memdesc:af1e21fd647773e3fcbeedd137b520580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#af1e21fd647773e3fcbeedd137b520580">More...</a><br/></td></tr>
<tr class="separator:af1e21fd647773e3fcbeedd137b520580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2e8367de42127278ce1d8c22bcbcaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1a2e8367de42127278ce1d8c22bcbcaa">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, int x_size, int y_size)</td></tr>
<tr class="memdesc:a1a2e8367de42127278ce1d8c22bcbcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#a1a2e8367de42127278ce1d8c22bcbcaa">More...</a><br/></td></tr>
<tr class="separator:a1a2e8367de42127278ce1d8c22bcbcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfaafe22b18f740f1f2248f3dc10b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#adbfaafe22b18f740f1f2248f3dc10b4a">cuda_tile</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, int x_size, int y_size, int z_size)</td></tr>
<tr class="memdesc:adbfaafe22b18f740f1f2248f3dc10b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this function is traversed.  <a href="#adbfaafe22b18f740f1f2248f3dc10b4a">More...</a><br/></td></tr>
<tr class="separator:adbfaafe22b18f740f1f2248f3dc10b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a08d7274c38d341388f0c2c9c9b32f287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y)</td></tr>
<tr class="memdesc:a08d7274c38d341388f0c2c9c9b32f287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the storage for the function is laid out.  <a href="#a08d7274c38d341388f0c2c9c9b32f287">More...</a><br/></td></tr>
<tr class="separator:a08d7274c38d341388f0c2c9c9b32f287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59d05f644880806b781b2ac638fd842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad59d05f644880806b781b2ac638fd842">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z)</td></tr>
<tr class="memdesc:ad59d05f644880806b781b2ac638fd842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the storage for the function is laid out.  <a href="#ad59d05f644880806b781b2ac638fd842">More...</a><br/></td></tr>
<tr class="separator:ad59d05f644880806b781b2ac638fd842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011438ae4c5e938a32aef32606e98e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a011438ae4c5e938a32aef32606e98e3a">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w)</td></tr>
<tr class="memdesc:a011438ae4c5e938a32aef32606e98e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the storage for the function is laid out.  <a href="#a011438ae4c5e938a32aef32606e98e3a">More...</a><br/></td></tr>
<tr class="separator:a011438ae4c5e938a32aef32606e98e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cf3f2c80e072fdd666172fd5426443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab6cf3f2c80e072fdd666172fd5426443">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t)</td></tr>
<tr class="memdesc:ab6cf3f2c80e072fdd666172fd5426443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the storage for the function is laid out.  <a href="#ab6cf3f2c80e072fdd666172fd5426443">More...</a><br/></td></tr>
<tr class="separator:ab6cf3f2c80e072fdd666172fd5426443"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a31abfa11a1fb6c1d1c24cfdc888079aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a31abfa11a1fb6c1d1c24cfdc888079aa">test</a> ()</td></tr>
<tr class="separator:a31abfa11a1fb6c1d1c24cfdc888079aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A halide function. </p>
<p>This class represents one stage in a <a class="el" href="namespace_halide.html">Halide</a> pipeline, and is the unit by which we schedule things. By default they are aggressively inlined, so you are encouraged to make lots of little functions, rather than storing things in Exprs. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00270">270</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a265d4e8c8c6225fb5455f4b6c3496db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a new undefined function with the given name. </p>

</div>
</div>
<a class="anchor" id="aed876d44c3e1dd0a72c4111afc63018b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Func::Func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a new undefined function with an automatically-generated unique name. </p>

</div>
</div>
<a class="anchor" id="a89aa00c3ee27c264979fd1b90f271085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Func::Func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a new function with an automatically-generated unique name, and define it to return the given expression (which may not contain free variables). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a31abfa11a1fb6c1d1c24cfdc888079aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Halide::Func::test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa304976dc9e5cd003a4c77409287e180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_buffer.html">Buffer</a> Halide::Func::realize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a new uniquely-named function that returns the given buffer. </p>
<p>Has the same dimensionality as the buffer. Useful for passing Images to c++ functions that expect Funcs Evaluate this function over some rectangular domain and return the resulting buffer. The buffer should probably be instantly wrapped in an <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> class of the appropriate type. That is, do this:</p>
<p>Image&lt;float&gt; im = f.realize(...);</p>
<p>not this:</p>
<p><a class="el" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> im = f.realize(...) </p>

</div>
</div>
<a class="anchor" id="a50a033e71f69cdfbf9f0329b2adc05c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate this function into an existing allocated buffer. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. </p>

</div>
</div>
<a class="anchor" id="af1766b2c9fe767ebe835b807db8b73cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_bitcode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function. </p>

</div>
</div>
<a class="anchor" id="a38ad88b379adececdd34bdfbc9c0fd2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function. </p>
<p>You probably don't want to use this directly - instead call compile_to_file. </p>

</div>
</div>
<a class="anchor" id="aae9623ffff43b170735b65c490b68ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_header </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a header file with the given filename for this function. </p>
<p>The header will define a function with the type signature given by the second argument, and a name given by the third. The name defaults to the same name as this halide function. You don't actually have to have defined this function yet to call this. You probably don't want to use this directly</p>
<ul>
<li>instead call compile_to_file. </li>
</ul>

</div>
</div>
<a class="anchor" id="a2d16f8fb285adf13ec7c10ff5bc1a4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to text assembly equivalent to the object file generated by compile_to_object. </p>
<p>This is useful for checking what <a class="el" href="namespace_halide.html">Halide</a> is producing without having to disassemble anything, or if you need to feed the assembly into some custom toolchain to produce an object file (e.g. iOS) </p>

</div>
</div>
<a class="anchor" id="a04a6c208a0d447cb9e28c088d138e0a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_c </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile this function to C source code. </p>
<p>This is useful for providing fallback code paths that will compile on many platforms. Vectorization will fail, and parallelization will produce serial code. </p>

</div>
</div>
<a class="anchor" id="a68c638e672ab03f4c6d33b3d18a38bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="ad298bdaa8046ed536fb0caa41b8afed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="ac3d70781dcc8d7ce235afb03671f1b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="aad32263aeca597b89ef1a4c2f21d6daf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="afaee49e35c41c750493ed4c54fa6e328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a65ae1dcf2cacf172217cb9f895881f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a464ce3192ec9a6840d312b97667552c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a43d7d8baab31e6e34f6862cb653b66f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void* Halide::Func::compile_jit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eagerly jit compile the function to machine code. </p>
<p>This normally happens on the first call to realize. If you're running your halide pipeline inside time-sensitive code and wish to avoid including the time taken to compile a pipeline, then you can call this ahead of time. Returns the raw function pointer to the compiled pipeline. </p>

</div>
</div>
<a class="anchor" id="a785ff1f13e2c194280e6dd9db17c0a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::set_error_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)(char *)&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the error handler function that be called in the case of runtime errors during halide pipelines. </p>
<p>If you are compiling statically, you can also just define your own function with signature </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> halide_error(<span class="keywordtype">char</span> *)</div>
</div><!-- fragment --><p> This will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="ab08dcceb9c5fb0205815c52100327f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::set_custom_allocator </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t)&#160;</td>
          <td class="paramname"><em>malloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom malloc and free for halide to use. </p>
<p>Malloc should return 32-byte aligned chunks of memory, with 32-bytes extra allocated on the start and end so that vector loads can spill off the end slightly. Metadata (e.g. the base address of the region allocated) can go in this margin - it is only read, not written. If you are compiling statically, you can also just define your own functions with signatures </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *malloc(<span class="keywordtype">size_t</span>) </div>
<div class="line">extern &quot;C&quot; <span class="keywordtype">void</span> halide_free(<span class="keywordtype">void</span> *)</div>
</div><!-- fragment --><p> These will clobber <a class="el" href="namespace_halide.html">Halide</a>'s versions. </p>

</div>
</div>
<a class="anchor" id="a32a4c3f59b390c6766650351c69b945f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::set_custom_do_task </td>
          <td>(</td>
          <td class="paramtype">void(*)(void(*)(int, uint8_t *), int, uint8_t *)&#160;</td>
          <td class="paramname"><em>custom_do_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom task handler to be called by the parallel for loop. </p>
<p>It is useful to set this if you want to do some additional bookkeeping at the granularity of parallel tasks. The default implementation does this: </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> halide_do_task(<span class="keywordtype">void</span> (*f)(<span class="keywordtype">int</span>, uint8_t *), <span class="keywordtype">int</span> idx, uint8_t *state) {</div>
<div class="line">    f(idx, state);</div>
<div class="line">}</div>
</div><!-- fragment --><p> If you are statically compiling, you can also just define your own version of the above function, and it will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version.</p>
<p>If you're trying to use a custom parallel runtime, you probably don't want to call this. See instead <a class="el" href="class_halide_1_1_func.html#a3b6e8bec521c66b8621d1fa8bd405576">Func::set_custom_do_par_for</a> . </p>

</div>
</div>
<a class="anchor" id="a3b6e8bec521c66b8621d1fa8bd405576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::set_custom_do_par_for </td>
          <td>(</td>
          <td class="paramtype">void(*)(void(*)(int, uint8_t *), int, int, uint8_t *)&#160;</td>
          <td class="paramname"><em>custom_do_par_for</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom parallel for loop launcher. </p>
<p>Useful if your app already manages a thread pool. The default implementation is equivalent to this: </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> halide_do_par_for(<span class="keywordtype">void</span> (*f)(<span class="keywordtype">int</span> uint8_t *), <span class="keywordtype">int</span> <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">min</a>, <span class="keywordtype">int</span> extent, uint8_t *state) {</div>
<div class="line">    <a class="code" href="class_halide_1_1_func.html#a93ee31a00e40c4531af6f58187ee19b9" title="Scheduling calls that control how the domain of this function is traversed.">parallel</a> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = min; idx &lt; min+extent; idx++) {</div>
<div class="line">        halide_do_task(f, idx, state);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> If you are statically compiling, you can also just define your own version of the above function, and it will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="ad698122392e50574c38e3d19b0c9c41e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Func::debug_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When this function is compiled, include code that dumps its values to a file after it is realized, for the purpose of debugging. </p>
<p>The file covers the realized extent at the point in the schedule that debug_to_file appears.</p>
<p>If filename ends in ".tif" or ".tiff" (case insensitive) the file is in TIFF format and can be read by standard tools. Oherwise, the file format is as follows:</p>
<p>All data is in the byte-order of the target platform. First, a 20 byte-header containing four 32-bit ints, giving the extents of the first four dimensions. Dimensions beyond four are folded into the fourth. Then, a fifth 32-bit int giving the data type of the function. The typecodes are given by: float = 0, double = 1, uint8_t = 2, int8_t = 3, uint16_t = 4, uint32_t = 5, int32_t = 6, uint64_t = 7, int64_t = 8. The data follows the header, as a densely packed array of the given size and the given type. If given the extension .tmp, this file format can be natively read by the program ImageStack. </p>

</div>
</div>
<a class="anchor" id="a1c36026717d2f74a842983d65e6b3bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::string&amp; Halide::Func::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The name of this function, either given during construction, or automatically generated. </p>

</div>
</div>
<a class="anchor" id="a184f385b265e7ba488a2eed66a10b41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Func::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The right-hand-side value of the pure definition of this function. </p>
<p>May be undefined if the function has no pure definition yet. </p>

</div>
</div>
<a class="anchor" id="a8993a73f9eb2d0c7ccc58028447d42f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int Halide::Func::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The dimensionality (number of arguments) of this function. </p>
<p>Zero if the function is not yet defined. </p>

</div>
</div>
<a class="anchor" id="afb028626864f2a3f39641d00af78910f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a6ce0f0c6d8463c32f9ceacb0fe045051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a60a31dc608a3f44d6aadb2a6edc8f7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a0f2a51dc115473368299e9966979e530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="af64144c733800b0b6bc0f1d8108e2ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="aafd2a13dff2a024e86445e56c719503a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ad155774acf0b530a7bf1fb5f1b513c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ae126902d07bdf0bb9595ef9c36ce857c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a85c51b6c4753623f6c85d067bbe367ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ae37eb8a056b41e7983fc7127471c1350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a27b5159835278ac904ee9512608d2acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a2722b4f2538ddc74a966419d13b73b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a16ae313b5ed4cd15232e85d2901cb97f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a6b31299fe9c9d0c7e3ba7e34be4e8df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ac86c1602915f8a423faf62926201ad9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a reduction definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="abefe6262e23d34d161c7cc0b85e07187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a93ee31a00e40c4531af6f58187ee19b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a1cbde565654302d9c0ab9383a0e42708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="ab0055492c3b10965e1656f26431a01d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a34111b1eb2321cbde1515e307239df7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a46b181aa119bcf7319892a3bc060fcf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="afadd04bc51ed5999496eaa876a4ee790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a070bb51c52383bd6402d6002458a3788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="ab36a87a19b09e4a195afe3dce519cb63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a6fcab053b6cbebab50704aa82057a9eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="ab2e224ddf7cb7a6c72aa98ee97401716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="ac29cec9650d4d53f304ff737d68f13c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a86876a3812c3e74a6993b03825e18d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="ad7fc932b2a8be41af352c39f3128c74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a025fbc02ba21775bc17665d2a29c017c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a8e1f253d87e6052e39a6e672d8ddb7e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="aa48f5e79415eda6f01539dc0fc9ba05a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a94deb0bfb7286bf794cc0dcf00040a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a1e05993bf55b53825d1c036804aa05db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a50627066af66b070ce7f0515c733c4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a9970910f3fa8dd312cadf0b848eec1fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a251b2c0835d9ac9384729fe83d0b3ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a62623f10f29023c1bd6b871ad9ede757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="af1e21fd647773e3fcbeedd137b520580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a1a2e8367de42127278ce1d8c22bcbcaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="adbfaafe22b18f740f1f2248f3dc10b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::cuda_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this function is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> for the meanings. </p>

</div>
</div>
<a class="anchor" id="a08d7274c38d341388f0c2c9c9b32f287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the storage for the function is laid out. </p>
<p>Right now you can only reorder the dimensions. </p>

</div>
</div>
<a class="anchor" id="ad59d05f644880806b781b2ac638fd842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the storage for the function is laid out. </p>
<p>Right now you can only reorder the dimensions. </p>

</div>
</div>
<a class="anchor" id="a011438ae4c5e938a32aef32606e98e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the storage for the function is laid out. </p>
<p>Right now you can only reorder the dimensions. </p>

</div>
</div>
<a class="anchor" id="ab6cf3f2c80e072fdd666172fd5426443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::reorder_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the storage for the function is laid out. </p>
<p>Right now you can only reorder the dimensions. </p>

</div>
</div>
<a class="anchor" id="a11de589971243d53709563789ef09273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute this function as needed for each unique value of the given var for the given calling function f. </p>
<p>For example, consider the simple pipeline: </p>
<div class="fragment"><div class="line"><a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;</div>
<div class="line">Var x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</div>
</div><!-- fragment --><p>If we schedule f like so:</p>
<div class="fragment"><div class="line">g.compute_at(f, x); </div>
</div><!-- fragment --><p>Then the C code equivalent to this pipeline will look like this</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordtype">int</span> g[2][2];</div>
<div class="line">        g[0][0] = x*y;</div>
<div class="line">        g[0][1] = (x+1)*y;</div>
<div class="line">        g[1][0] = x*(y+1);</div>
<div class="line">        g[1][1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][0] + g[1][0] + g[0][1] + g[1][1];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The allocation and computation of g is within f's loop over x, and enough of g is computed to satisfy all that f will need for that iteration. This has excellent locality - values of g are used as soon as they are computed, but it does redundant work. Each value of g ends up getting computed four times. If we instead schedule f like so:</p>
<div class="fragment"><div class="line">g.compute_at(f, y);     </div>
</div><!-- fragment --><p>The equivalent C code is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][width+1]; </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        g[0][x] = x*y;</div>
<div class="line">        g[1][x] = x*(y+1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</div>
<div class="line">    }</div>
<div class="line">}     </div>
</div><!-- fragment --><p>The allocation and computation of g is within f's loop over y, and enough of g is computed to satisfy all that f will need for that iteration. This does less redundant work (each point in g ends up being evaluated twice), but the locality is not quite as good, and we have to allocate more temporary memory to store g. </p>

</div>
</div>
<a class="anchor" id="addf97325c7449720d8d84115353a2c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_r_var.html">RVar</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a function to be computed within the iteration over some dimension of a reduction domain. </p>
<p>Produces equivalent code to the version of compute_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>. </p>

</div>
</div>
<a class="anchor" id="a7f4db7e4884fe76399bf2a673567eab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::compute_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all of this function once ahead of time. </p>
<p>Reusing the example in <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Func::compute_at</a> :</p>
<div class="fragment"><div class="line"><a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;</div>
<div class="line">Var x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</div>
<div class="line"></div>
<div class="line">g.compute_root();</div>
</div><!-- fragment --><p>is equivalent to</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordtype">int</span> g[height+1][width+1];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height+1; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width+1; x++) {</div>
<div class="line">        g[y][x] = x*y;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        f[y][x] = g[y][x] + g[y+1][x] + g[y][x+1] + g[y+1][x+1];</div>
<div class="line">    }</div>
<div class="line">}          </div>
</div><!-- fragment --><p>g is computed once ahead of time, and enough is computed to satisfy all uses of it. This does no redundant work (each point in g is evaluated once), but has poor locality (values of g are probably not still in cache when they are used by f), and allocates lots of temporary memory to store g. </p>

</div>
</div>
<a class="anchor" id="a33cb0d00bc9585bf3027011ecb1412b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::store_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage for this function within f's loop over var. </p>
<p>Scheduling storage is optional, and can be used to separate the loop level at which storage occurs from the loop level at which computation occurs to trade off between locality and redundant work. This can open the door for two types of optimization.</p>
<p>Consider again the pipeline from <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Func::compute_at</a> : </p>
<div class="fragment"><div class="line"><a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;</div>
<div class="line">Var x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);</div>
</div><!-- fragment --><p>If we schedule it like so:</p>
<div class="fragment"><div class="line">g.compute_at(f, x).store_at(f, y);</div>
</div><!-- fragment --><p>Then the computation of g takes place within the loop over x, but the storage takes place within the loop over y:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][width+1]; </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        g[0][x] = x*y;</div>
<div class="line">        g[0][x+1] = (x+1)*y;</div>
<div class="line">        g[1][x] = x*(y+1);</div>
<div class="line">        g[1][x+1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</div>
<div class="line">    }</div>
<div class="line">}          </div>
</div><!-- fragment --><p>Provided the for loop over x is serial, halide then automatically performs the following sliding window optimization:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][width+1]; </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordflow">if</span> (x == 0) {</div>
<div class="line">            g[0][x] = x*y;</div>
<div class="line">            g[1][x] = x*(y+1);</div>
<div class="line">        }</div>
<div class="line">        g[0][x+1] = (x+1)*y;</div>
<div class="line">        g[1][x+1] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</div>
<div class="line">    }</div>
<div class="line">}          </div>
</div><!-- fragment --><p>Two of the assignments to g only need to be done when x is zero. The rest of the time, those sites have already been filled in by a previous iteration. This version has the locality of compute_at(f, x), but allocates more memory and does much less redundant work.</p>
<p><a class="el" href="namespace_halide.html">Halide</a> then further optimizes this pipeline like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordtype">int</span> g[2][2]; </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        <span class="keywordflow">if</span> (x == 0) {</div>
<div class="line">            g[0][0] = x*y;</div>
<div class="line">            g[1][0] = x*(y+1);</div>
<div class="line">        }</div>
<div class="line">        g[0][(x+1)%2] = (x+1)*y;</div>
<div class="line">        g[1][(x+1)%2] = (x+1)*(y+1);</div>
<div class="line">        f[y][x] = g[0][x%2] + g[1][x%2] + g[0][(x+1)%2] + g[1][(x+1)%2];</div>
<div class="line">    }</div>
<div class="line">}          </div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html">Halide</a> has detected that it's possible to use a circular buffer to represent g, and has reduced all accesses to g modulo 2 in the x dimension. This optimization only triggers if the for loop over x is serial, and if halide can statically determine some power of two large enough to cover the range needed. For powers of two, the modulo operator compiles to more efficient bit-masking. This optimization reduces memory usage, and also improves locality by reusing recently-accessed memory instead of pulling new memory into cache. </p>

</div>
</div>
<a class="anchor" id="a61980a1317bdbd1017f284414865deac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::store_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_r_var.html">RVar</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain. </p>

</div>
</div>
<a class="anchor" id="a7048eaf680bc0c78961c0bef48d37f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::store_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">Func::store_at</a>, but schedules storage outside the outermost loop. </p>

</div>
</div>
<a class="anchor" id="a6b824c681a83aba8e318652bade047dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; Halide::Func::compute_inline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggressively inline all uses of this function. </p>
<p>This is the default schedule, so you're unlikely to need to call this. For a reduction, that means it gets computed as close to the innermost loop as possible.</p>
<p>Consider once more the pipeline from <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Func::compute_at</a> :</p>
<div class="fragment"><div class="line"><a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;</div>
<div class="line">Var x, y;</div>
<div class="line">g(x, y) = x*y;</div>
<div class="line">f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);</div>
</div><!-- fragment --><p>Leaving g as inline, this compiles to code equivalent to the following C:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f[height][width];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {</div>
<div class="line">        f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);</div>
<div class="line">    }</div>
<div class="line">}   </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acac11539aa8f54ae551f34b79bc68d19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_schedule_handle.html">ScheduleHandle</a> Halide::Func::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle on the update step of a reduction for the purposes of scheduling it. </p>
<p>Only the pure dimensions of the update step can be meaningfully manipulated (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>) </p>

</div>
</div>
<a class="anchor" id="af53d44302c15c4335e55a2887e2f780e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> Halide::Func::function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle on the internal halide function that this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> represents. </p>
<p>Useful if you want to do introspection on <a class="el" href="namespace_halide.html">Halide</a> functions </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00852">852</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="af30b03fbc4252d7e3c4baa63feedf8bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::operator <a class="el" href="struct_halide_1_1_expr.html">Expr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casting a function to an expression is equivalent to calling the function with zero arguments. </p>
<p>Implicit variables will be injected according to the function's dimensionality (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>).</p>
<p>Combined with <a class="el" href="class_halide_1_1_func.html#a351b971607afe7e65e121f43510554aa" title="Define a function to take a number of arguments according to the implicit variables present in the gi...">Func::operator=</a>, this lets you write things like:</p>
<div class="fragment"><div class="line"><a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;</div>
<div class="line">Var x;</div>
<div class="line">g(x) = ...     </div>
<div class="line">f = g * 2;</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_func_8h_source.html#l00869">869</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="a351b971607afe7e65e121f43510554aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a function to take a number of arguments according to the implicit variables present in the given expression, and return the given expression. </p>
<p>The expression may not have free variables. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00877">877</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9069edd2d55144f818c4ceb612d22b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Func::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a function to simply call another function. </p>
<p>Note that this is not equivalent to the standard c++ operator=. We opt instead for consistency with <a class="el" href="namespace_halide.html">Halide</a> function definition, of which this is a degenerate case. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00885">885</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_func.html">Func</a></li>
    <li class="footer">Generated on Wed May 29 2013 16:11:50 for Halide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
